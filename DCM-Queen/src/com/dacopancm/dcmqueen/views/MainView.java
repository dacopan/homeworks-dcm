/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.dacopancm.dcmqueen.views;

import com.dacopancm.dcmqueen.helpers.Egg;
import com.dacopancm.dcmqueen.conmponents.ChessBoard;
import com.dacopancm.dcmqueen.conmponents.Queen;
import com.dacopancm.dcmqueen.helpers.DesktopApi;
import eu.hansolo.custom.SteelCheckBox;
import eu.hansolo.steelseries.tools.BackgroundColor;
import eu.hansolo.steelseries.tools.ColorDef;
import eu.hansolo.steelseries.tools.DesignModel;
import eu.hansolo.steelseries.tools.FrameDesign;
import eu.hansolo.steelseries.tools.LcdColor;
import eu.hansolo.steelseries.tools.PointerType;
import eu.hansolo.steelseries.tools.SmoothingFunction;
import java.awt.Color;
import java.awt.Container;
import java.awt.Dimension;
import java.awt.HeadlessException;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.io.File;
import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URISyntaxException;
import java.net.URL;
import java.util.ArrayList;
import java.util.BitSet;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.AbstractButton;
import javax.swing.ImageIcon;
import javax.swing.JComponent;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.KeyStroke;
import javax.swing.border.Border;
import org.jachievement.Achievement;
import org.jachievement.AchievementConfig;
import org.jachievement.AchievementPosition;
import org.jachievement.AchievementQueue;

/**
 * Algoritmos-UCE
 *
 * @author dacopanCM
 * @copyright Copyright (C) 2014 dacopanCM. All rights reserved.
 * @license GNU General Public License version 3 or later; see LICENSE.txt
 * @website http://dacopancm.hol.es/blog/about Aquí va la magia, muestra la
 * ventana principal y unica de la app
 */
public class MainView extends javax.swing.JFrame implements MouseListener, MouseMotionListener {

    /**
     * Creates new form MainView
     */
    public MainView() {
        this.appMode = AppMode.ANIMATION;
        initComponents();

        initConfigs();
        initActionListeners();
        setExtendedState(java.awt.Frame.MAXIMIZED_BOTH);
        //setIconImage(Queen.icon.getImage());
        setIconImage(Toolkit.getDefaultToolkit().getImage(this.getClass().getResource("/com/dacopancm/dcmqueen/resources/queen2.png")));
        enableDisableTools(false);

        //configuracion del JFileChooser para respaldar
        saveDCM = new JFileChooser();
        saveDCM.setDialogType(JFileChooser.SAVE_DIALOG);
        saveDCM.setDialogTitle("Guardar captura de ChessBoard");
        saveDCM.setCurrentDirectory(new File(System.getProperty("user.home") + System.getProperty("file.separator") + "Desktop"));
        saveDCM.setApproveButtonText("Guardar");
        saveDCM.setFileFilter(new DCMFIlter());

    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jSplitPane1 = new javax.swing.JSplitPane();
        jPanel1 = new javax.swing.JPanel();
        queenWraper = new javax.swing.JPanel();
        chessBoardWrapper = new javax.swing.JLayeredPane();
        jPanel2 = new javax.swing.JPanel();
        jPanel5 = new javax.swing.JPanel();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        gauge1Wrap = new javax.swing.JPanel();
        gauge2Wrap = new javax.swing.JPanel();
        jPanel6 = new javax.swing.JPanel();
        jScrollPane1 = new javax.swing.JScrollPane();
        noticex = new javax.swing.JTextArea();
        switchWrapper = new javax.swing.JPanel();
        reloadBut = new javax.swing.JButton();
        pausebutton = new javax.swing.JToggleButton();
        gauguesWrap1 = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        velocityControl = new javax.swing.JSlider();
        snapBut = new javax.swing.JButton();
        jPanel7 = new javax.swing.JPanel();
        jPanel4 = new javax.swing.JPanel();
        gplBut = new javax.swing.JButton();
        helpBut = new javax.swing.JButton();
        aboutBut = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("DCM Queen");

        jSplitPane1.setDividerLocation(670);

        jPanel1.setBorder(javax.swing.BorderFactory.createMatteBorder(1, 4, 1, 1, new java.awt.Color(0, 102, 0)));
        jPanel1.setMinimumSize(new java.awt.Dimension(670, 100));
        jPanel1.setPreferredSize(new java.awt.Dimension(670, 547));

        javax.swing.GroupLayout queenWraperLayout = new javax.swing.GroupLayout(queenWraper);
        queenWraper.setLayout(queenWraperLayout);
        queenWraperLayout.setHorizontalGroup(
            queenWraperLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 645, Short.MAX_VALUE)
        );
        queenWraperLayout.setVerticalGroup(
            queenWraperLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 100, Short.MAX_VALUE)
        );

        javax.swing.GroupLayout chessBoardWrapperLayout = new javax.swing.GroupLayout(chessBoardWrapper);
        chessBoardWrapper.setLayout(chessBoardWrapperLayout);
        chessBoardWrapperLayout.setHorizontalGroup(
            chessBoardWrapperLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 644, Short.MAX_VALUE)
        );
        chessBoardWrapperLayout.setVerticalGroup(
            chessBoardWrapperLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 686, Short.MAX_VALUE)
        );

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(chessBoardWrapper)
                    .addComponent(queenWraper, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap())
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(queenWraper, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(chessBoardWrapper)
                .addContainerGap())
        );

        jSplitPane1.setLeftComponent(jPanel1);

        jPanel2.setBorder(javax.swing.BorderFactory.createMatteBorder(4, 1, 1, 1, new java.awt.Color(102, 0, 102)));

        jPanel5.setMaximumSize(new java.awt.Dimension(295, 219));

        jLabel2.setFont(new java.awt.Font("Segoe UI", 0, 14)); // NOI18N
        jLabel2.setText("Totales");

        jLabel3.setFont(new java.awt.Font("Segoe UI", 0, 14)); // NOI18N
        jLabel3.setText("Particular");

        gauge1Wrap.setMaximumSize(new java.awt.Dimension(100, 189));
        gauge1Wrap.setMinimumSize(new java.awt.Dimension(100, 189));

        javax.swing.GroupLayout gauge1WrapLayout = new javax.swing.GroupLayout(gauge1Wrap);
        gauge1Wrap.setLayout(gauge1WrapLayout);
        gauge1WrapLayout.setHorizontalGroup(
            gauge1WrapLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 100, Short.MAX_VALUE)
        );
        gauge1WrapLayout.setVerticalGroup(
            gauge1WrapLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 0, Short.MAX_VALUE)
        );

        javax.swing.GroupLayout gauge2WrapLayout = new javax.swing.GroupLayout(gauge2Wrap);
        gauge2Wrap.setLayout(gauge2WrapLayout);
        gauge2WrapLayout.setHorizontalGroup(
            gauge2WrapLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 0, Short.MAX_VALUE)
        );
        gauge2WrapLayout.setVerticalGroup(
            gauge2WrapLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 0, Short.MAX_VALUE)
        );

        javax.swing.GroupLayout jPanel5Layout = new javax.swing.GroupLayout(jPanel5);
        jPanel5.setLayout(jPanel5Layout);
        jPanel5Layout.setHorizontalGroup(
            jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel5Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel2)
                    .addComponent(jLabel3))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(gauge1Wrap, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(gauge2Wrap, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );
        jPanel5Layout.setVerticalGroup(
            jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel5Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(gauge2Wrap, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addGroup(jPanel5Layout.createSequentialGroup()
                        .addGap(27, 27, 27)
                        .addComponent(jLabel2)
                        .addGap(26, 26, 26)
                        .addComponent(jLabel3)
                        .addContainerGap(49, Short.MAX_VALUE))
                    .addGroup(jPanel5Layout.createSequentialGroup()
                        .addComponent(gauge1Wrap, javax.swing.GroupLayout.PREFERRED_SIZE, 131, Short.MAX_VALUE)
                        .addContainerGap())))
        );

        jPanel6.setBackground(new java.awt.Color(91, 57, 182));
        jPanel6.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(103, 74, 185), 2));
        jPanel6.setMaximumSize(new java.awt.Dimension(331, 91));
        jPanel6.setMinimumSize(new java.awt.Dimension(331, 91));

        jScrollPane1.setBorder(null);

        noticex.setEditable(false);
        noticex.setBackground(new java.awt.Color(91, 57, 182));
        noticex.setColumns(20);
        noticex.setFont(new java.awt.Font("Segoe UI", 0, 14)); // NOI18N
        noticex.setForeground(new java.awt.Color(255, 255, 255));
        noticex.setLineWrap(true);
        noticex.setRows(5);
        noticex.setWrapStyleWord(true);
        noticex.setBorder(null);
        noticex.setCaretColor(new java.awt.Color(204, 0, 204));
        noticex.setMargin(new java.awt.Insets(0, 0, 0, 0));
        noticex.setMaximumSize(new java.awt.Dimension(240, 100));
        noticex.setMinimumSize(new java.awt.Dimension(240, 100));
        jScrollPane1.setViewportView(noticex);

        javax.swing.GroupLayout jPanel6Layout = new javax.swing.GroupLayout(jPanel6);
        jPanel6.setLayout(jPanel6Layout);
        jPanel6Layout.setHorizontalGroup(
            jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel6Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 404, Short.MAX_VALUE)
                .addContainerGap())
        );
        jPanel6Layout.setVerticalGroup(
            jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel6Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane1)
                .addContainerGap())
        );

        switchWrapper.setBorder(javax.swing.BorderFactory.createTitledBorder("Tools"));

        reloadBut.setIcon(new javax.swing.ImageIcon(getClass().getResource("/com/dacopancm/dcmqueen/resources/refresh.png"))); // NOI18N

        pausebutton.setIcon(new javax.swing.ImageIcon(getClass().getResource("/com/dacopancm/dcmqueen/resources/pause.png"))); // NOI18N

        gauguesWrap1.setMaximumSize(new java.awt.Dimension(220, 220));
        gauguesWrap1.setPreferredSize(new java.awt.Dimension(220, 220));

        javax.swing.GroupLayout gauguesWrap1Layout = new javax.swing.GroupLayout(gauguesWrap1);
        gauguesWrap1.setLayout(gauguesWrap1Layout);
        gauguesWrap1Layout.setHorizontalGroup(
            gauguesWrap1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 0, Short.MAX_VALUE)
        );
        gauguesWrap1Layout.setVerticalGroup(
            gauguesWrap1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 0, Short.MAX_VALUE)
        );

        jLabel1.setFont(new java.awt.Font("Segoe UI", 0, 14)); // NOI18N
        jLabel1.setText("Velocidad de Ejecución");

        snapBut.setIcon(new javax.swing.ImageIcon(getClass().getResource("/com/dacopancm/dcmqueen/resources/snapshoot.png"))); // NOI18N

        jPanel7.setBorder(javax.swing.BorderFactory.createTitledBorder(javax.swing.BorderFactory.createMatteBorder(5, 1, 1, 1, new java.awt.Color(102, 0, 102))));
        jPanel7.setPreferredSize(new java.awt.Dimension(80, 51));

        gplBut.setIcon(new javax.swing.ImageIcon(getClass().getResource("/com/dacopancm/dcmqueen/resources/gpl.png"))); // NOI18N

        helpBut.setIcon(new javax.swing.ImageIcon(getClass().getResource("/com/dacopancm/dcmqueen/resources/help.png"))); // NOI18N
        helpBut.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                helpButActionPerformed(evt);
            }
        });

        aboutBut.setIcon(new javax.swing.ImageIcon(getClass().getResource("/com/dacopancm/dcmqueen/resources/about.png"))); // NOI18N

        javax.swing.GroupLayout jPanel4Layout = new javax.swing.GroupLayout(jPanel4);
        jPanel4.setLayout(jPanel4Layout);
        jPanel4Layout.setHorizontalGroup(
            jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel4Layout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel4Layout.createSequentialGroup()
                        .addComponent(helpBut, javax.swing.GroupLayout.PREFERRED_SIZE, 42, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(aboutBut, javax.swing.GroupLayout.PREFERRED_SIZE, 42, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addComponent(gplBut, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 98, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap())
        );
        jPanel4Layout.setVerticalGroup(
            jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel4Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(gplBut)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(helpBut)
                    .addComponent(aboutBut))
                .addContainerGap())
        );

        javax.swing.GroupLayout jPanel7Layout = new javax.swing.GroupLayout(jPanel7);
        jPanel7.setLayout(jPanel7Layout);
        jPanel7Layout.setHorizontalGroup(
            jPanel7Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel7Layout.createSequentialGroup()
                .addGap(0, 0, Short.MAX_VALUE)
                .addComponent(jPanel4, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
        );
        jPanel7Layout.setVerticalGroup(
            jPanel7Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel7Layout.createSequentialGroup()
                .addComponent(jPanel4, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 0, Short.MAX_VALUE))
        );

        javax.swing.GroupLayout switchWrapperLayout = new javax.swing.GroupLayout(switchWrapper);
        switchWrapper.setLayout(switchWrapperLayout);
        switchWrapperLayout.setHorizontalGroup(
            switchWrapperLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(switchWrapperLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(switchWrapperLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(switchWrapperLayout.createSequentialGroup()
                        .addComponent(reloadBut)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(pausebutton)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(snapBut)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 88, Short.MAX_VALUE)
                        .addComponent(jPanel7, javax.swing.GroupLayout.PREFERRED_SIZE, 120, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(switchWrapperLayout.createSequentialGroup()
                        .addGroup(switchWrapperLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(velocityControl, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel1))
                        .addGap(57, 57, 57)
                        .addComponent(gauguesWrap1, javax.swing.GroupLayout.DEFAULT_SIZE, 252, Short.MAX_VALUE)))
                .addContainerGap())
        );
        switchWrapperLayout.setVerticalGroup(
            switchWrapperLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(switchWrapperLayout.createSequentialGroup()
                .addGroup(switchWrapperLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(switchWrapperLayout.createSequentialGroup()
                        .addGap(34, 34, 34)
                        .addGroup(switchWrapperLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(pausebutton)
                            .addComponent(reloadBut)
                            .addComponent(snapBut)))
                    .addComponent(jPanel7, javax.swing.GroupLayout.PREFERRED_SIZE, 114, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGroup(switchWrapperLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(switchWrapperLayout.createSequentialGroup()
                        .addGap(101, 101, 101)
                        .addComponent(jLabel1)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(velocityControl, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addContainerGap(196, Short.MAX_VALUE))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, switchWrapperLayout.createSequentialGroup()
                        .addGap(36, 36, 36)
                        .addComponent(gauguesWrap1, javax.swing.GroupLayout.DEFAULT_SIZE, 302, Short.MAX_VALUE)
                        .addContainerGap())))
        );

        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(switchWrapper, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jPanel5, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel2Layout.createSequentialGroup()
                        .addGap(0, 106, Short.MAX_VALUE)
                        .addComponent(jPanel6, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap())
        );
        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jPanel5, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(jPanel6, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(switchWrapper, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );

        jSplitPane1.setRightComponent(jPanel2);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jSplitPane1)
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jSplitPane1)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void helpButActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_helpButActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_helpButActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(MainView.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                MainView mv = new MainView();
                mv.setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton aboutBut;
    private javax.swing.JLayeredPane chessBoardWrapper;
    private javax.swing.JPanel gauge1Wrap;
    private javax.swing.JPanel gauge2Wrap;
    private javax.swing.JPanel gauguesWrap1;
    private javax.swing.JButton gplBut;
    private javax.swing.JButton helpBut;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JPanel jPanel4;
    private javax.swing.JPanel jPanel5;
    private javax.swing.JPanel jPanel6;
    private javax.swing.JPanel jPanel7;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JSplitPane jSplitPane1;
    private javax.swing.JTextArea noticex;
    private javax.swing.JToggleButton pausebutton;
    private javax.swing.JPanel queenWraper;
    private javax.swing.JButton reloadBut;
    private javax.swing.JButton snapBut;
    private javax.swing.JPanel switchWrapper;
    private javax.swing.JSlider velocityControl;
    // End of variables declaration//GEN-END:variables

    // <editor-fold defaultstate="collapsed" desc="init Configurations">
    /**
     * init All with default configs
     */
    private void initConfigs() {
        reloadChessboard();
        Border d = javax.swing.BorderFactory.createTitledBorder("");
        // chessBoardWrapper.setBorder(d);
        queenWraper.setBorder(d);

        loadQueens(true);

        iPause = new javax.swing.ImageIcon(getClass().getResource("/com/dacopancm/dcmqueen/resources/pause.png"));
        iPlay = new javax.swing.ImageIcon(getClass().getResource("/com/dacopancm/dcmqueen/resources/play.png"));

        initGaugues();
        //init threads
        algR = new AlgRunnable();
        alg = new Thread(algR);

        this.switchMode = new SteelCheckBox();
        //this.switchMode=new JButton(" xxx");
        switchMode.setPreferredSize(new Dimension(120, 30));
        switchMode.setBounds(25, 320, 120, 30);
        switchMode.setSelectedColor(eu.hansolo.tools.ColorDef.RED);
        switchMode.setColored(true);
        switchMode.setRised(true);
        switchMode.setText("Modo Juego");
        //switchMode.setSize(120, 300);*/

        switchWrapper.add(switchMode);
        userQueen = new ArrayList();
    }

    /**
     * init chessboard with default configs
     */
    private void reloadChessboard() {
        chessBoard = new ChessBoard();
        chessBoardWrapper.removeAll();
        chessBoardWrapper.setPreferredSize(new Dimension(560, 540));
        chessBoard.setBounds(30, 30, 560, 540);
        chessBoardWrapper.add(chessBoard);

    }

    /**
     * load the 8 queens before Chessboard
     *
     * @param ix
     */
    private void loadQueens(boolean enDrag) {
        System.out.println("Load queens: " + this.appMode);
        queenWraper.removeAll();
        // userQueen = new ArrayList();
        queens = new Queen[8];

        if (queens[0] != null) {
            for (int i = 0; i < 8; i++) {
                queens[i].removeMouseMotionListener(this);
                queens[i].removeMouseListener(this);
            }

        }
        final int SPACE = 20;
        Border d = javax.swing.BorderFactory.createTitledBorder("");
        for (int i = 0; i < 8; i++) {
            queens[i] = new Queen(QUEEN_SIZE - 20);
            queens[i].setBounds(QUEEN_SIZE * i + SPACE * 1, 30, QUEEN_SIZE, QUEEN_SIZE);
            queens[i].setBorder(d);
            queenWraper.add(queens[i]);
        }

        if (enDrag) {
            for (int i = 0; i < (this.appMode == AppMode.GAME ? 8 : 1); i++) {
                queenWraper.remove(queens[i]);
                //queenWraper.remove(queens[0]);
                Rectangle gb = queens[i].getBounds();
                gb.y = 100;
                gb.x += 20;
                queens[i].setBounds(gb);
                chessBoardWrapper.add(queens[i]);
                chessBoardWrapper.moveToFront(queens[i]);
                if (queens[i] != null && queens[i].isDraggable()) {
                    queens[i].addMouseMotionListener(this);
                    queens[i].addMouseListener(this);

                    noticex.setText("DCM Queen.");
                }
                //queenWraper.repaint();
            }
            showNotify("Mueva a la reina a la posicion deseada, para comenzar");
        }
        queenWraper.repaint();

    }
    // </editor-fold>
    // <editor-fold defaultstate="collapsed" desc="init ActionListeners and gauge">
    /**
     * inicializa los action listeners de todos los componentes q lo requieran
     */
    private void initActionListeners() {

        pausebutton.addActionListener(new java.awt.event.ActionListener() {

            @Override
            public void actionPerformed(ActionEvent e) {
                System.out.println("pause invoke");
                if (pause) {
                    pausebutton.setIcon(iPause);
                    pausebutton.setToolTipText("Pause");
                    gauge.setValueAnimated(velocityControl.getValue());
                    showNotify("DCM Queen", "Reanudando Animación");
                } else {
                    pausebutton.setIcon(iPlay);
                    pausebutton.setToolTipText("Play");
                    gauge.setValueAnimated(0);
                    showNotify("DCM Queen", "Pausando Animación");
                }
                pause = !pause;
            }
        });

        reloadBut.addActionListener(new java.awt.event.ActionListener() {

            @Override
            public void actionPerformed(ActionEvent e) {
                new Thread(new Runnable() {

                    @Override
                    public void run() {
                        System.out.println("reload invoke");
                        VELOCITY_ALG = 0;
                        toggleProgres(true);
                        if (pause) {
                            pausebutton.doClick();
                        }
                        enableDisableTools(false);
                        if (alg.isAlive()) {
                            pause = false;
                            algR.rebornThread();
                            algR.killThread();
                        }
                        try {

                            alg.join();
                            System.out.println("alg after join");
                            toggleProgres(false);
                            reloadChessboard();
                            System.out.println("before load queens reloadBut");
                            loadQueens(true);
                            pause = false;

                            initGaugues();
                            //enableDisableTools(true);

                            switchMode.setSelected(AppMode.GAME == appMode);
                            if (appMode == AppMode.GAME) {
                                enableDisableTools(false);
                                reloadBut.setEnabled(true);
                                snapBut.setEnabled(true);
                                VELOCITY_ALG = 0;

                                pause = false;
                            }
                            chessBoardWrapper.invalidate();
                            chessBoardWrapper.repaint();
                            userQueen = new ArrayList();

                        } catch (InterruptedException ex) {
                            System.out.println("Error: " + ex.getMessage());
                        }
                        switchWrapper.repaint();
                    }

                }).start();
            }
        });

        switchMode.addActionListener(new java.awt.event.ActionListener() {
            @Override
            public void actionPerformed(ActionEvent actionEvent) {

                final AbstractButton abstractButton = (AbstractButton) actionEvent.getSource();
                new Thread(new Runnable() {

                    @Override
                    public void run() {
                        boolean selected = abstractButton.getModel().isSelected();
                        enableDisableTools(true);

                        if (selected) {

                            appMode = AppMode.GAME;
                            reloadBut.doClick();

                            try {
                                Thread.sleep(300);
                            } catch (InterruptedException ex) {
                                Logger.getLogger(MainView.class.getName()).log(Level.SEVERE, null, ex);
                            }
                            appMode = AppMode.GAME;

                            showNotify("Modo Juego activado");
                        } else {
                            appMode = AppMode.ANIMATION;
                            reloadBut.doClick();
                            showNotify("Modo Animación activado");
                        }

                    }
                }).start();
            }
        });

        velocityControl.addChangeListener(new javax.swing.event.ChangeListener() {
            @Override
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                gauge.setValueAnimated(velocityControl.getValue());
                VELOCITY_ALG = 80 - velocityControl.getValue();
            }
        });

        gplBut.addActionListener(new ActionListener() {

            @Override
            public void actionPerformed(ActionEvent e) {
                URL url;
                try {
                    url = new URL("http://www.gnu.org/licenses/gpl-3.0-standalone.html");
                    try {
                        DesktopApi.browse(url.toURI());
                    } catch (URISyntaxException ex) {
                        System.out.println(ex.getMessage());
                    }
                } catch (MalformedURLException e1) {
                    System.out.println(e1.getMessage());
                }
            }
        });

        aboutBut.addActionListener(new ActionListener() {

            @Override
            public void actionPerformed(ActionEvent e) {
                URL url;
                try {
                    url = new URL("http://dacopancm.hol.es/blog/about");
                    try {
                        DesktopApi.browse(url.toURI());
                    } catch (URISyntaxException ex) {
                        System.out.println(ex.getMessage());
                    }
                } catch (MalformedURLException e1) {
                    System.out.println(e1.getMessage());
                }
            }
        });
        helpBut.addActionListener(new ActionListener() {

            @Override
            public void actionPerformed(ActionEvent e) {
                callHelp();

            }
        });
        
         snapBut.addActionListener(new ActionListener() {

            @Override
            public void actionPerformed(ActionEvent e) {
                //chessBoard.getImg(System.getProperty("user.dir") + System.getProperty("file.separator") + "x.jpg");
                //System.out.println(System.getProperty("user.dir") + System.getProperty("file.separator") + "x.jpg");

                try {
                    saveDCM.setSelectedFile(new File("DCMQueen_Snapshot.jpg"));
                    if (saveDCM.showSaveDialog(getRootPane()) == JFileChooser.APPROVE_OPTION) {
                        File f = saveDCM.getSelectedFile();

                        String path = (f.getCanonicalPath() + (f.getCanonicalPath().endsWith(".jpg") ? "" : ".jpg")).replace("\\", "/");
                        System.out.println(path);
                        boolean _r = chessBoard.getImg(path);
                        if (_r) {
                            showNotify("DCM Queen", "Reinas hiperactivas guardadas con éxito");
                        } else {
                            showNotify("DCM Queen Error", "Lamentamos, hemos teneido inconvenientes generando la captura");
                        }
                    }
                } catch (HeadlessException | IOException ex) {
                    showNotify("DCM Queen Error", "Lamentamos, hemos teneido inconvenientes generando la captura: " + ex.getMessage());
                }

            }
        });
         
        jSplitPane1.registerKeyboardAction(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                callHelp();
            }
        }, KeyStroke.getKeyStroke("F1"), JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);

        jSplitPane1.registerKeyboardAction(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {                
                Egg.main(null);
            }
        }, KeyStroke.getKeyStroke("control alt M"), JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);

       //reload short cut
        jSplitPane1.registerKeyboardAction(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                reloadBut.doClick();
            }
        }, KeyStroke.getKeyStroke("control R"), JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);

        //snap short cut
        jSplitPane1.registerKeyboardAction(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                snapBut.doClick();
            }
        }, KeyStroke.getKeyStroke("control S"), JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);

        //play/pause short cut
        jSplitPane1.registerKeyboardAction(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                pausebutton.doClick();
            }
        }, KeyStroke.getKeyStroke("control P"), JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);

    }

    /**
     * inicializa y configura el gauge de velocidad y el slider
     */
    private void initGaugues() {
        gauguesWrap1.removeAll();
        gauge1Wrap.removeAll();
        gauge2Wrap.removeAll();

        gauge = new eu.hansolo.steelseries.gauges.Radial();
        gauge.setBounds(0, 0, 200, 200);
        gauge.setPreferredSize(new Dimension(200, 200));
        gauge.setUnitString("ejecución");
        gauge.setPointerType(PointerType.TYPE1);
        gauge.setTitle("Velocidad");

        gauge.setPointerColor(ColorDef.ORANGE);
        //r.setBackgroundColor(BackgroundColor.NOISY_PLASTIC);
        gauge.setBackgroundColor(BackgroundColor.PUNCHED_SHEET);

        gauge.setMaxValue(80);
        gauge.setMinValue(0);
        gauge.setValue(6.8);
        //LCD
        gauge.setLcdColor(LcdColor.GREEN_LCD);
        gauge.setLcdDecimals(2);
        gauge.setDigitalFont(true);
        //track        
        gauge.setTrackStart(60);
        gauge.setTrackStartColor(Color.GREEN);
        gauge.setTrackSection(70);
        gauge.setTrackSectionColor(Color.YELLOW);
        gauge.setTrackStop(80);
        gauge.setTrackStopColor(Color.RED);
        gauge.setHighlightSection(false);
        gauge.setTrackVisible(true);

        DesignModel night = new DesignModel.Builder().frameDesign(FrameDesign.BLACK_METAL)
                .backgroundColor(BackgroundColor.BLACK).lcdColor(LcdColor.GREEN_LCD)
                .color(ColorDef.RED)
                .build();

        gauguesWrap1.add(gauge);

        //SLIDER
        velocityControl.setMinimum(1);
        velocityControl.setMaximum(80);
        velocityControl.setValue(15);

        //solutions gaugues
        gaugeSol1 = new eu.hansolo.steelseries.gauges.DisplaySingle();
        gaugeSol1.setBounds(10, 10, 80, 50);
        gaugeSol1.setDigitalFont(true);
        gaugeSol1.setLcdColor(LcdColor.DARKBLUE_LCD);
        gaugeSol1.setLcdDecimals(0);
        gaugeSol1.setLcdUnitString("Sol.");
        gaugeSol1.setLcdValueAnimated(0);

        gauge1Wrap.add(gaugeSol1);

        gaugeSol2 = new eu.hansolo.steelseries.gauges.DisplaySingle();
        gaugeSol2.setBounds(10, 70, 80, 50);
        gaugeSol2.setDigitalFont(true);
        gaugeSol2.setLcdColor(LcdColor.REDDARKRED_LCD);
        gaugeSol2.setLcdDecimals(0);
        gaugeSol2.setLcdUnitString("Sol.");
        gaugeSol2.setLcdValueAnimated(0);

        gauge1Wrap.add(gaugeSol2);
        gauge1Wrap.setPreferredSize(new Dimension(100, 120));

        //counter gauges
        gaugeSol3 = new eu.hansolo.steelseries.gauges.DisplaySingle();
        gaugeSol3.setBounds(10, 10, 180, 50);
        gaugeSol3.setDigitalFont(true);
        gaugeSol3.setLcdColor(LcdColor.GRAY_LCD);
        gaugeSol3.setLcdDecimals(0);
        gaugeSol3.setLcdUnitString("Backtraking");
        gaugeSol3.setLcdValueAnimated(0);

        gauge2Wrap.add(gaugeSol3);

        gaugeSol4 = new eu.hansolo.steelseries.gauges.DisplaySingle();
        gaugeSol4.setBounds(200, 10, 170, 50);
        gaugeSol4.setDigitalFont(true);
        gaugeSol4.setLcdColor(LcdColor.DARKBLUE_LCD);
        gaugeSol4.setLcdDecimals(0);
        gaugeSol4.setLcdUnitString("recursive");
        gaugeSol4.setLcdValueAnimated(0);

        gauge2Wrap.add(gaugeSol4);

        gaugeSol5 = new eu.hansolo.steelseries.gauges.SparkLine();
        gaugeSol5.setBounds(10, 70, 360, 70);
        gaugeSol5.setBackgroundVisible(true);
        gaugeSol5.setHiLoIndicatorVisible(true);
        gaugeSol5.setStartStopIndicatorVisible(true);
        gaugeSol5.setInfoLabelsVisible(true);
        gaugeSol5.setFilled(true);

        gaugeSol5.setSparkLineColor(LcdColor.REDDARKRED_LCD);
        //gaugeSol5.addDataPoint(0);
        gaugeSol5.setSmoothFunction(SmoothingFunction.HERMITE);
        gaugeSol5.setSmoothing(false);

        gaugeSol5.setTimeFrame(100);
//        gaugeSol5.addDataPoint(1,20);
//        gaugeSol5.setTimeFrame(20);
//        gaugeSol5.addDataPoint(2,40);
//        gaugeSol5.setTimeFrame(40);
//        gaugeSol5.addDataPoint(3,60);
//        gaugeSol5.setTimeFrame(60);
//        gaugeSol5.addDataPoint(4,80);
//        gaugeSol5.addDataPoint(1,90);
//        //gaugeSol5.setTimeFrame(90);
        gauge2Wrap.add(gaugeSol5);

    }

    // </editor-fold>
    // <editor-fold defaultstate="collapsed" desc="Helpers, notifys, etc">
    public void showNotify(String text) {
        showNotify("DCM Queen", text);
    }

    /**
     * Muestra notificacion Toast
     *
     * @param title
     * @param text
     */
    public void showNotify(String title, String text) {
        try {
            AchievementConfig config = new AchievementConfig();

            config.setBackgroundColor(new java.awt.Color(13, 142, 161));
            config.setTitleColor(Color.WHITE);
            config.setDescriptionColor(Color.WHITE);
            config.setBorderColor(new java.awt.Color(58, 161, 192));
            config.setAchievementPosition(AchievementPosition.TOP_RIGHT);
            config.setDuration(2500);
            //config.setIcon(new javax.swing.ImageIcon(getClass().getResource("/com/dacopancm/dcmqueen/resources/queen2.png")));
            config.setIcon(Queen.icon);
            //config.setAudioInputStream(null);

            Achievement achievement = new Achievement(title, text, config);
            AchievementQueue queue = new AchievementQueue();
            queue.add(achievement);
        } catch (Exception ex) {
//            Log.e("Error", "su OS no soporta notificaciones", ex);
        }
    }

    /**
     * enable/disable pause and refresh buttons
     *
     * @param act enable/disable
     */
    private void enableDisableTools(boolean act) {

        try {
            pausebutton.setEnabled(act);
            reloadBut.setEnabled(act);
            snapBut.setEnabled(act);
            velocityControl.setEnabled(act);
            gauge.setEnabled(act);
            if (act) {
                velocityControl.setValue(35);
                gauge.setValue(35);
            }
        } catch (Exception ex) {
            System.out.println("(e)enableDisableTools: " + ex.getMessage());
        }
    }

    /**
     * muestra la ayuda en formato HTML5 en el navegador web predeterminado en
     * el Sistema operativo. Solo Windows
     */
    private void callHelp() {
        URL url;
        try {

            String userDir = System.getProperty("user.dir");
            String spliter = System.getProperty("file.separator");
            // String filePath = userDir + spliter + "resources" + spliter + "help" + spliter + "index.html";
            String filePath = "resources" + spliter + "help" + spliter + "index.html";
            File fileHelp = new File(filePath);
            if (fileHelp.exists()) {
                //fileHelp.delete();
                System.out.println("help exist");

            }
            url = fileHelp.toURI().toURL();
            //InputStream streamIn = getClass().getResourceAsStream("/com/dacopancm/ordenamientos/resources/help.html");
            //Files.copy(streamIn, fileHelp.toPath());
            try {
                DesktopApi.browse(url.toURI());
            } catch (URISyntaxException ex) {
                System.out.println("error: " + ex.getMessage());
            }
        } catch (MalformedURLException e1) {
            System.out.println("error: " + e1.getMessage());
        }
    }

    /**
     * show/ocult progressring en lugar de chessBoard
     *
     * @param b true show progress
     */
    private void toggleProgres(boolean b) {
        chessBoard.toggleProgres(b, (this.appMode == AppMode.ANIMATION ? "Killing Queens, Wait" : "Intercambiando Modo"));
    }

    private void toggleProgres(boolean b, String text) {
        chessBoard.toggleProgres(b, text);
    }

    /**
     * clase para filtar extensiones JFileChooser
     */
    class DCMFIlter extends javax.swing.filechooser.FileFilter {

        @Override
        public boolean accept(File f) {
            return f.isDirectory() || f.getName().toLowerCase().endsWith(".jpg");
        }

        @Override
        public String getDescription() {
            return "Imagenes (.jpg)";
        }
    }

    // </editor-fold>
    // <editor-fold defaultstate="collapsed" desc="Mouse Listener">
    //todos estos metodos son para controlae el drag & drog de la primera reina
    @Override
    public void mouseClicked(MouseEvent e) {
        if (this.appMode == AppMode.GAME) {
            Queen qq = (Queen) e.getSource();
            if (!qq.isDraggable()) {
                Container parent = qq.getParent();
                Rectangle rc = parent.getBounds();
                Rectangle rc2 = qq.getBounds();
                rc2.x = rc.x;
                rc2.y = rc.y;
                chessBoard.cleenCell(parent);
                parent.repaint();

                qq.setBounds(rc2);
                chessBoardWrapper.add(qq);
                chessBoardWrapper.moveToFront(qq);
                chessBoard.repaint();
                qq.setDraggable(true);
            }
        }
    }

    @Override
    public void mousePressed(MouseEvent e) {
        //showNotify(null);
        System.out.println("drag start");
    }

    @Override
    public void mouseReleased(MouseEvent e) {
        Queen qq = (Queen) e.getSource();
        System.out.println("Fin draged");
        int x = qq.getX() - 30;
        int y = qq.getY() - 30;
        boolean isLastQueen = true;
        if (qq.isDraggable()) {
            qq.setDraggable(false);
            int _r = 0;
            if (appMode == AppMode.GAME) {
                for (Queen qqc : queens) {
                    if (qqc.isDraggable()) {
                        isLastQueen = false;
                        break;
                    }
                }
            }
            if (isLastQueen) {
                _r = JOptionPane.showConfirmDialog(this, "Colocar reina y comenzar ?", "DCM Queen ", JOptionPane.YES_NO_OPTION);
            }

            if (_r == 0) {
                boolean _r2 = chessBoard.addAtCell(new Point(x, y), qq);
                if (qq.getPoint() != null) {
                    userQueen.remove(qq.getPoint());
                }
                userQueen.add(chessBoard.getUserSelectPoint());
                qq.setPoint(chessBoard.getUserSelectPoint());
                if (_r2) {

                    qq.setDraggable(false);
                    qq.setBounds(0, 0, qq.getWidth(), qq.getHeight());
                    chessBoardWrapper.remove(qq);
                    chessBoard.repaint();

                    if (this.appMode == AppMode.ANIMATION || isLastQueen) {
                        showNotify("Iniciando animacion");
                        executeAlg();
                    }

                } else {
                }
            } else {
                qq.setDraggable(true);
            }
        }
    }

    @Override
    public void mouseEntered(MouseEvent e) {
        //   System.out.println("XX");
    }

    @Override
    public void mouseExited(MouseEvent e) {
        // System.out.println("XX");
    }
//drag

    @Override
    public void mouseDragged(MouseEvent E) {
        Queen qq = (Queen) E.getSource();
        if (qq.isDraggable()) {
            int X = E.getX() + qq.getX();
            int Y = E.getY() + qq.getY();
            int chessX = chessBoard.getBounds().x;
            int chessY = chessBoard.getBounds().y;

            int maxX = chessX + chessBoard.getBounds().width;
            int maxY = chessY + chessBoard.getBounds().height;
            if ((X + QUEEN_SIZE) > maxX) {
                X = maxX - QUEEN_SIZE;
            } else if ((X) < chessX) {
                X = chessX;
            }
            if ((Y + QUEEN_SIZE) > maxY) {
                Y = maxY - QUEEN_SIZE;
            } else if ((Y) < chessY) {
                Y = chessY;
            }
            qq.setBounds(X, Y, QUEEN_SIZE, QUEEN_SIZE);
        }
    }

    @Override
    public void mouseMoved(MouseEvent e) {

    }
// </editor-fold>

    // <editor-fold defaultstate="collapsed" desc="Therads">
    private void executeAlg() {
        enableDisableTools(true);
        if (appMode == AppMode.GAME) {
            enableDisableTools(false);
            reloadBut.setEnabled(true);
            snapBut.setEnabled(true);
            VELOCITY_ALG = 0;
            pause = false;
        }
        alg = new Thread(algR);
        algR.rebornThread();
        alg.start();
    }

    /**
     * el Runnable encargado de la MAGIA
     */
    private class AlgRunnable implements Runnable {

        private boolean killed;
        private List<Integer> Solution;
        private List<Integer> ans;
        int VELOCITY_ALG2 = 100;
        private int solu1 = 0;
        private int solu2 = 0;
        private int calls = 0;
        private int backtraking = 0;
        private int backtraking2 = 0;
        private int time = 0;
        private boolean isGameOver;

        /**
         * asesina al Thread
         */
        public void killThread() {
            this.killed = true;
        }

        /**
         * revive al Thread
         */
        public void rebornThread() {
            this.killed = false;
        }

        /**
         * inicia la magia
         */
        @Override
        public void run() {
            BitSet RowsToBeFilled = new BitSet(9);
            BitSet ColsToBeFilled = new BitSet(9);
            BitSet LeftDiag = new BitSet(16);
            BitSet RightDiag = new BitSet(16);
            for (int i = 1; i < 9; i++) {
                RowsToBeFilled.set(i);
                ColsToBeFilled.set(i);
            }
            for (int j = 1; j < 16; j++) {
                LeftDiag.set(j);
                RightDiag.set(j);
            }
            this.Solution = new ArrayList();
            backtraking = 0;
            backtraking2 = 0;
            if (appMode == AppMode.GAME) {
                toggleProgres(true, "Verificando solución");
                VELOCITY_ALG = 0;
                gauge.setValue(80);
                VELOCITY_ALG = 0;
                isGameOver = true;

            }

            backtraking(RowsToBeFilled, ColsToBeFilled, LeftDiag, RightDiag);
            //call algoritm
            if (appMode == AppMode.GAME) {
                String content;
                if (isGameOver) {
                    content = "Game Over";
                } else {
                    content = "Enhorabuena, ganaste";
                }
                toggleProgres(true);

                showNotify(content);
                //chessBoard.repaint();
                chessBoard.gameEnd(content);
            }

            switchWrapper.repaint();
            /*
             try {
             Thread.sleep(1000000000);
             } catch (InterruptedException ex) {
             Logger.getLogger(MainView.class.getName()).log(Level.SEVERE, null, ex);
             }//*/
        }

        /**
         * El MAGO, metodo backtraking recursivo que encuentra las soluciones
         *
         * @param RowsToBeFilled
         * @param ColsToBeFilled
         * @param LeftDiag
         * @param RightDiag
         */
        private void backtraking(BitSet RowsToBeFilled, BitSet ColsToBeFilled, BitSet LeftDiag, BitSet RightDiag) {
            pauseAlg();//CHECK PAUSE
            if (killed) {
                System.out.println("KILLED");
                return;
            }
            if (setSelected(0)) {
                return;
            }
            try {
                Thread.sleep(VELOCITY_ALG * 80 + 10);
                // Thread.yield();
            } catch (InterruptedException le) {
            }
            fireCallEvent();
            if (setSelected(3)) {
                return;
            }
            if (setSelected(3, "Declarar variables locales para la llamada de este metodo")) {
                return;
            }

            if (setSelected(4, "Hacer una copia de los BitSet para que los cambios puedan ser echos al BitSet localmente sin cambiar al BitSet pasado en la la llamada al método")) {
                return;
            }

            BitSet localBitSet1 = (BitSet) ColsToBeFilled.clone();

            BitSet localBitSet2 = (BitSet) RowsToBeFilled.clone();
            if (setSelected(6, "El primer paso en cualquier solución recursiva es comprobar si el problema encaja en la categoría de caso base. En este caso, comprobamos para ver si ocho reina han sido retardada en el tablero de ajedrez? - El caso base para el Eight Queens problema.")) {
                return;
            }
            if (empty(RowsToBeFilled)) {
                if (setSelected(7, "Se ha llegado al caso base se ha encontrado una solución. Observe que el sparkline está mostrando 9 llamadas recursivas abierto. Esto se debe a que no es hasta la novena llamada que el caso base está satisfecho.")) {
                    return;
                }

                updateDisplay(this.Solution, true);
                //fireSolutionEvent();        
                //backtraking2 = 1;
                gaugeSol5.addDataPoint(0, ++time);
                gaugeSol1.setLcdValueAnimated(++solu1);
                chessBoard.repaint();

                if (checkSolution()) {
                    pausebutton.doClick();
                    showNotify("Solución encontrada");
                    gaugeSol2.setLcdValueAnimated(++solu2);
                    // chessBoard.repaint();

                    if (appMode == AppMode.GAME) {
                        System.out.println("Modo juego solucion encontrada");
                        isGameOver = false;
                        pause = false;
                        killThread();
                        return;
                    }
                }
                try {
                    Thread.sleep(2000L);
                } catch (InterruptedException le) {
                    System.out.println("???");
                }

                if (setSelected(10, "Backtrack y tratar de encontrar otras soluciones")) {
                    //return;
                }
            } else {
                if (setSelected(11, "Como se puede ver en la animación que todavía no hemos llegado a la hipótesis de base, ya que sólo "
                        + count(RowsToBeFilled)
                        + " Queens se han colocado en el tablero.")) {
                    return;
                }

                if (setSelected(13, " Busca la siguiente fila donde se debe colocar una reina (i.e, Fila" + (count(RowsToBeFilled) + 1) + ")")) {
                    return;
                }
                int i = AnyFrom(localBitSet2);
                if (setSelected(14, " ajustar CopyOfRowsToBeFilled de manera que la fila " + (count(RowsToBeFilled) + 1)
                        + " ahora se marca como una reina colocada allí.")) {
                    return;
                }
                localBitSet2.clear(i);

                if (setSelected(15, " Ahora tenemos que decidir dónde en la columna "
                        + count(localBitSet2)
                        + " podemos colocar una reina sin ser atacados "
                        + "por otra(s) reina(s)"
                        + "que ya están en el tablero")) {
                    return;
                }
                while (!empty(localBitSet1)) {
                    if (killed) {
                        System.out.println("KILLED 2");
                        return;
                    }
                    pauseAlg();//CHECK PAUSE
                    if (setSelected(16)) {
                        return;
                    }
                    int j = AnyFrom(localBitSet1);
                    if (setSelected(17, " Pruebe a ver si es seguro para colocar una reina en posición " + j
                            + " de columna " + count(localBitSet2) + ".")) {
                        return;
                    }

                    try {
                        localBitSet1.clear(j);
                    } catch (Exception e) {
                        System.out.println("BITSET ERROR");
                    }

                    if ((LeftDiag.get(i + j - 1) & RightDiag.get(i - j + 8))) {
                        if (setSelected(20, "Posición " + j
                                + " de comlumna " + count(localBitSet2)
                                + " es una posición segura para una Reina.")) {
                            return;
                        }

                        try {
                            this.Solution.add(j);
                        } catch (Exception e) {
                            System.out.println("ERROR: " + e.getMessage());
                        }
                        updateDisplay(this.Solution);
                        // Thread.yield();
                        if (setSelected(22, " Por colocar una Reina en la posición " + j
                                + " de la columna " + count(localBitSet2)
                                + " cualquier posición a lo largo de las diagonales de esta posición se convierten en "
                                + " inseguro para otra reina. Registramos las diagonales"
                                + " efectuado aquí.")) {
                            return;
                        }
                        ColsToBeFilled.clear(j);

                        LeftDiag.clear(i + j - 1);

                        RightDiag.clear(i - j + 8);
                        if (setSelected(25,
                                "Ahora hacemos una llamada recursiva para tratar de encontrar la siguiente ubicación para una reina. Como acabamos elaborado un lugar seguro en esta fila se pidió la llamada recursiva para resolver una versión simplificada del mismo problema. Observe que el sparkline aumento.")) {
                            return;
                        }

                        backtraking(localBitSet2, ColsToBeFilled,
                                LeftDiag, RightDiag);
                        if (setSelected(27, " Este es el punto de retorno de una llamada recursiva, el sparkline se reduce en uno, La solución que se ha sugerido se ha intentado, liberar la posición que había colocado una reina para que yo pudiera sugerir otra solución")) {
                            return;
                        }

                        fireBackTrackEvent();
                        ColsToBeFilled.set(j);

                        this.Solution.remove(this.Solution.size() - 1);

                        pauseAlg();//CHECK PAUSE
                        if (killed) {
                            System.out.println("KILLED3");
                            return;
                        }

                        updateDisplay(this.Solution);

                        LeftDiag.set(i + j - 1);

                        RightDiag.set(i - j + 8);
                    } else {
                        if (setSelected(15, "No es seguro para colocar una reina en la posición " + j
                                + " de la columna " + count(localBitSet2)
                                + "  Sería atacada a lo largo de una de sus diagonales.")) {
                            return;
                        }
                    }

                }
                if (setSelected(33, "No hay posiciones más seguras para poner a prueba en la fila actual, el tiempo de hacer un backtrack!")) {

                }
            }

        }

        /**
         * la magia misma, actualiza el chessBoard
         *
         * @param paramVector solucion
         */
        public void updateDisplay(List<Integer> paramVector) {
            this.ans = paramVector;
            pushQueens();
        }

        /**
         * la magia misma, actualiza el chessBoard
         *
         * @param paramVector solucion
         */
        public void updateDisplay(List<Integer> paramVector, boolean paramBoolean) {
            this.ans = paramVector;
            pushQueens();
        }

        /**
         * coloca las reinas necesarias, en el chessboard
         */
        private void pushQueens() {
            chessBoard.removeAllQueens();
            if ((this.ans != null) && (!this.ans.isEmpty())) {
                int m;
                loadQueens(false);
                for (m = 0; m < this.ans.size(); m++) {
                    int x = m;
                    int y = 0;
                    try {
                        y = (this.ans.get(m) - 1);
                    } catch (Exception e) {
                    }
                    System.out.println("Push queens:(" + x + ", " + y + ")");

                    chessBoard.addCom(x, y, queens[m]);
                    queens[m].setBounds(0, 0, queens[0].getWidth(), queens[0].getHeight());
                    chessBoard.repaint();
                    queenWraper.remove(queens[m]);
                    queenWraper.repaint();
                }

            }/* else if ((this.ans != null) && (this.ans.isEmpty())) {
             //this.buff.setColor(Color.blue);
             }*/

        }

        /**
         * retorna un int Pos vacia del BitSet
         *
         * @param paramBitSet bitSet de donde obtener el nuemro
         * @return
         */
        private int AnyFrom(BitSet paramBitSet) {
            int i = 1;
            while (!paramBitSet.get(i)) {
                i++;
            }
            return i;
        }

        /**
         * comprueba si esta vacio el BitSet
         *
         * @param paramBitSet true si esta vacio el BitSet
         * @return
         */
        private boolean empty(BitSet paramBitSet) {
            for (int i = 1; i < 9; i++) {
                if (paramBitSet.get(i)) {
                    return false;
                }
            }
            return true;
        }

        /**
         * Cuenta en el BitSet
         *
         * @param paramBitSet el count del BitSet
         * @return
         */
        private int count(BitSet paramBitSet) {
            int i = 0;
            for (int j = 1; j < 9; j++) {
                if (!paramBitSet.get(j)) {
                    i++;
                }
            }
            return i;
        }

        /**
         * Checa y comprueba si se pausa el algoritmo
         */
        private void pauseAlg() {
            if (pause) {
                try {
                    Thread.sleep(500);
                } catch (InterruptedException ex) {
                }
                pauseAlg();
            }
        }

        /**
         * Muestra en el Noticex un status
         *
         * @param i linea
         * @return
         */
        private boolean setSelected(int i) {
            System.out.println(i);
            return false;
        }

        /**
         * Muestra en el Noticex un status
         *
         * @param i
         * @param s status a mostrar
         * @return si se mato al hilo
         */
        private boolean setSelected(int i, String s) {
            System.out.println(i + ": " + s);
            noticex.setText(s);
            try {
                //  Thread.currentThread();
                Thread.sleep(VELOCITY_ALG * 80 + 1);
            } catch (InterruptedException lie) {
                System.out.println("Wake up and do some thing");
            }
            return killed;
        }

        /**
         * comprueba si la solucion encontrada contiene, a la reina ubicada en
         * la posicion seleccionada por el usuario
         *
         * @param ans solucion encontrada
         * @return true si es la solucion buscada
         */
        private boolean checkSolution() {
            List<Point> solPoints = new ArrayList();
            for (int m = 0; m < this.ans.size(); m++) {
                // chessBoard.addCom(m, m, this);
                int x = m;
                int y = ((this.ans.get(m)) - 1);
                solPoints.add(new Point(x, y));
            }

            return solPoints.containsAll(userQueen);
        }

        /**
         * evento cuando se llama el metodo, aumenta/disminuye los counter
         * necesarios
         */
        private void fireCallEvent() {
            gaugeSol3.setLcdValueAnimated(++calls);
            //time+=20;
            //gaugeSol5.setTimeFrame(time += 20);
            //gaugeSol5.setTimeFrame(time = 200);
            gaugeSol5.addDataPoint(++backtraking2, ++time);
            System.out.printf("dataPoint %d,%d\n\n", backtraking2, time);
        }

        /**
         * evento cuando se hace BackTrack, aumenta/disminuye los counter
         * necesarios
         */
        private void fireBackTrackEvent() {
            gaugeSol4.setLcdValueAnimated(++backtraking);

            //gaugeSol5.setTimeFrame(time += 20);
            gaugeSol5.addDataPoint(--backtraking2, ++time);
            System.out.printf("dataPoint %d,%d\n\n", backtraking2, time);
        }
    }
        // </editor-fold>

    // <editor-fold defaultstate="collapsed" desc="Variable declaration">
    private ChessBoard chessBoard;
    private boolean pause = false;
    private int VELOCITY_ALG;
    private ImageIcon iPause;
    private ImageIcon iPlay;
    private eu.hansolo.steelseries.gauges.Radial gauge;
    private Queen[] queens;
    private Thread alg;
    private AlgRunnable algR;
    final int QUEEN_SIZE = 70;
    private final JFileChooser saveDCM;
    private List<Point> userQueen;

    private eu.hansolo.steelseries.gauges.DisplaySingle gaugeSol1;
    private eu.hansolo.steelseries.gauges.DisplaySingle gaugeSol2;
    private eu.hansolo.steelseries.gauges.DisplaySingle gaugeSol3;
    private eu.hansolo.steelseries.gauges.DisplaySingle gaugeSol4;
    private eu.hansolo.steelseries.gauges.SparkLine gaugeSol5;

    eu.hansolo.custom.SteelCheckBox switchMode;
//    JButton switchMode;
    AppMode appMode;

    public enum AppMode {

        GAME, ANIMATION
    }
    // </editor-fold>
}

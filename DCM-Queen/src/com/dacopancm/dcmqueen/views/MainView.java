/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.dacopancm.dcmqueen.views;

import com.dacopancm.dcmqueen.helpers.Egg;
import com.dacopancm.dcmqueen.conmponents.ChessBoard;
import com.dacopancm.dcmqueen.conmponents.Queen;
import com.dacopancm.dcmqueen.helpers.DesktopApi;
import eu.hansolo.custom.SteelCheckBox;
import eu.hansolo.steelseries.tools.BackgroundColor;
import eu.hansolo.steelseries.tools.ColorDef;
import eu.hansolo.steelseries.tools.DesignModel;
import eu.hansolo.steelseries.tools.FrameDesign;
import eu.hansolo.steelseries.tools.LcdColor;
import eu.hansolo.steelseries.tools.PointerType;
import eu.hansolo.steelseries.tools.SmoothingFunction;
import java.awt.Color;
import java.awt.Container;
import java.awt.Dimension;
import java.awt.HeadlessException;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.io.File;
import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URISyntaxException;
import java.net.URL;
import java.util.ArrayList;
import java.util.BitSet;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.AbstractButton;
import javax.swing.ImageIcon;
import javax.swing.JComponent;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.KeyStroke;
import javax.swing.border.Border;
import org.jachievement.Achievement;
import org.jachievement.AchievementConfig;
import org.jachievement.AchievementPosition;
import org.jachievement.AchievementQueue;

/**
 * Algoritmos-UCE
 *
 * @author dacopanCM
 * @copyright Copyright (C) 2014 dacopanCM. All rights reserved.
 * @license GNU General Public License version 3 or later; see LICENSE.txt
 * @website http://dacopancm.hol.es/blog/about Aqu√≠ va la magia, muestra la
 * ventana principal y unica de la app
 */
public class MainView extends javax.swing.JFrame implements MouseListener, MouseMotionListener {

    /**
     * Creates new form MainView
     */
    public MainView() {
        this.appMode = AppMode.ANIMATION;
        initComponents();

        initConfigs();
        initActionListeners();
        setExtendedState(java.awt.Frame.MAXIMIZED_BOTH);
        //setIconImage(Queen.icon.getImage());
        setIconImage(Toolkit.getDefaultToolkit().getImage(this.getClass().getResource("/com/dacopancm/dcmqueen/resources/queen2.png")));
        enableDisableTools(false);

        //configuracion del JFileChooser para respaldar
        saveDCM = new JFileChooser();
        saveDCM.setDialogType(JFileChooser.SAVE_DIALOG);
        saveDCM.setDialogTitle("Guardar captura de ChessBoard");
        saveDCM.setCurrentDirectory(new File(System.getProperty("user.home") + System.getProperty("file.separator") + "Desktop"));
        saveDCM.setApproveButtonText("Guardar");
        saveDCM.setFileFilter(new DCMFIlter());

    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jSplitPane1 = new javax.swing.JSplitPane();
        jPanel1 = new javax.swing.JPanel();
        queenWraper = new javax.swing.JPanel();
        chessBoardWrapper = new javax.swing.JLayeredPane();
        jPanel2 = new javax.swing.JPanel();
        jPanel5 = new javax.swing.JPanel();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        gauge1Wrap = new javax.swing.JPanel();
        gauge2Wrap = new javax.swing.JPanel();
        jPanel6 = new javax.swing.JPanel();
        jScrollPane1 = new javax.swing.JScrollPane();
        noticex = new javax.swing.JTextArea();
        switchWrapper = new javax.swing.JPanel();
        reloadBut = new javax.swing.JButton();
        pausebutton = new javax.swing.JToggleButton();
        gauguesWrap1 = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        velocityControl = new javax.swing.JSlider();
        snapBut = new javax.swing.JButton();
        jPanel7 = new javax.swing.JPanel();
        jPanel4 = new javax.swing.JPanel();
        gplBut = new javax.swing.JButton();
        helpBut = new javax.swing.JButton();
        aboutBut = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("DCM Queen");

        jSplitPane1.setDividerLocation(670);

        jPanel1.setBorder(javax.swing.BorderFactory.createMatteBorder(1, 4, 1, 1, new java.awt.Color(0, 102, 0)));
        jPanel1.setMinimumSize(new java.awt.Dimension(670, 100));
        jPanel1.setPreferredSize(new java.awt.Dimension(670, 547));

        javax.swing.GroupLayout queenWraperLayout = new javax.swing.GroupLayout(queenWraper);
        queenWraper.setLayout(queenWraperLayout);
        queenWraperLayout.setHorizontalGroup(
            queenWraperLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 645, Short.MAX_VALUE)
        );
        queenWraperLayout.setVerticalGroup(
            queenWraperLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 100, Short.MAX_VALUE)
        );

        javax.swing.GroupLayout chessBoardWrapperLayout = new javax.swing.GroupLayout(chessBoardWrapper);
        chessBoardWrapper.setLayout(chessBoardWrapperLayout);
        chessBoardWrapperLayout.setHorizontalGroup(
            chessBoardWrapperLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 644, Short.MAX_VALUE)
        );
        chessBoardWrapperLayout.setVerticalGroup(
            chessBoardWrapperLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 686, Short.MAX_VALUE)
        );

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(chessBoardWrapper)
                    .addComponent(queenWraper, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap())
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(queenWraper, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(chessBoardWrapper)
                .addContainerGap())
        );

        jSplitPane1.setLeftComponent(jPanel1);

        jPanel2.setBorder(javax.swing.BorderFactory.createMatteBorder(4, 1, 1, 1, new java.awt.Color(102, 0, 102)));

        jPanel5.setMaximumSize(new java.awt.Dimension(295, 219));

        jLabel2.setFont(new java.awt.Font("Segoe UI", 0, 14)); // NOI18N
        jLabel2.setText("Totales");

        jLabel3.setFont(new java.awt.Font("Segoe UI", 0, 14)); // NOI18N
        jLabel3.setText("Particular");

        gauge1Wrap.setMaximumSize(new java.awt.Dimension(100, 189));
        gauge1Wrap.setMinimumSize(new java.awt.Dimension(100, 189));

        javax.swing.GroupLayout gauge1WrapLayout = new javax.swing.GroupLayout(gauge1Wrap);
        gauge1Wrap.setLayout(gauge1WrapLayout);
        gauge1WrapLayout.setHorizontalGroup(
            gauge1WrapLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 100, Short.MAX_VALUE)
        );
        gauge1WrapLayout.setVerticalGroup(
            gauge1WrapLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 0, Short.MAX_VALUE)
        );

        javax.swing.GroupLayout gauge2WrapLayout = new javax.swing.GroupLayout(gauge2Wrap);
        gauge2Wrap.setLayout(gauge2WrapLayout);
        gauge2WrapLayout.setHorizontalGroup(
            gauge2WrapLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 0, Short.MAX_VALUE)
        );
        gauge2WrapLayout.setVerticalGroup(
            gauge2WrapLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 0, Short.MAX_VALUE)
        );

        javax.swing.GroupLayout jPanel5Layout = new javax.swing.GroupLayout(jPanel5);
        jPanel5.setLayout(jPanel5Layout);
        jPanel5Layout.setHorizontalGroup(
            jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel5Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel2)
                    .addComponent(jLabel3))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(gauge1Wrap, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(gauge2Wrap, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );
        jPanel5Layout.setVerticalGroup(
            jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel5Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(gauge2Wrap, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addGroup(jPanel5Layout.createSequentialGroup()
                        .addGap(27, 27, 27)
                        .addComponent(jLabel2)
                        .addGap(26, 26, 26)
                        .addComponent(jLabel3)
                        .addContainerGap(49, Short.MAX_VALUE))
                    .addGroup(jPanel5Layout.createSequentialGroup()
                        .addComponent(gauge1Wrap, javax.swing.GroupLayout.PREFERRED_SIZE, 131, Short.MAX_VALUE)
                        .addContainerGap())))
        );

        jPanel6.setBackground(new java.awt.Color(91, 57, 182));
        jPanel6.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(103, 74, 185), 2));
        jPanel6.setMaximumSize(new java.awt.Dimension(331, 91));
        jPanel6.setMinimumSize(new java.awt.Dimension(331, 91));

        jScrollPane1.setBorder(null);

        noticex.setEditable(false);
        noticex.setBackground(new java.awt.Color(91, 57, 182));
        noticex.setColumns(20);
        noticex.setFont(new java.awt.Font("Segoe UI", 0, 14)); // NOI18N
        noticex.setForeground(new java.awt.Color(255, 255, 255));
        noticex.setLineWrap(true);
        noticex.setRows(5);
        noticex.setWrapStyleWord(true);
        noticex.setBorder(null);
        noticex.setCaretColor(new java.awt.Color(204, 0, 204));
        noticex.setMargin(new java.awt.Insets(0, 0, 0, 0));
        noticex.setMaximumSize(new java.awt.Dimension(240, 100));
        noticex.setMinimumSize(new java.awt.Dimension(240, 100));
        jScrollPane1.setViewportView(noticex);

        javax.swing.GroupLayout jPanel6Layout = new javax.swing.GroupLayout(jPanel6);
        jPanel6.setLayout(jPanel6Layout);
        jPanel6Layout.setHorizontalGroup(
            jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel6Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 404, Short.MAX_VALUE)
                .addContainerGap())
        );
        jPanel6Layout.setVerticalGroup(
            jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel6Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane1)
                .addContainerGap())
        );

        switchWrapper.setBorder(javax.swing.BorderFactory.createTitledBorder("Tools"));

        reloadBut.setIcon(new javax.swing.ImageIcon(getClass().getResource("/com/dacopancm/dcmqueen/resources/refresh.png"))); // NOI18N

        pausebutton.setIcon(new javax.swing.ImageIcon(getClass().getResource("/com/dacopancm/dcmqueen/resources/pause.png"))); // NOI18N

        gauguesWrap1.setMaximumSize(new java.awt.Dimension(220, 220));
        gauguesWrap1.setPreferredSize(new java.awt.Dimension(220, 220));

        javax.swing.GroupLayout gauguesWrap1Layout = new javax.swing.GroupLayout(gauguesWrap1);
        gauguesWrap1.setLayout(gauguesWrap1Layout);
        gauguesWrap1Layout.setHorizontalGroup(
            gauguesWrap1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 0, Short.MAX_VALUE)
        );
        gauguesWrap1Layout.setVerticalGroup(
            gauguesWrap1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 0, Short.MAX_VALUE)
        );

        jLabel1.setFont(new java.awt.Font("Segoe UI", 0, 14)); // NOI18N
        jLabel1.setText("Velocidad de Ejecuci√≥n");

        snapBut.setIcon(new javax.swing.ImageIcon(getClass().getResource("/com/dacopancm/dcmqueen/resources/snapshoot.png"))); // NOI18N

        jPanel7.setBorder(javax.swing.BorderFactory.createTitledBorder(javax.swing.BorderFactory.createMatteBorder(5, 1, 1, 1, new java.awt.Color(102, 0, 102))));
        jPanel7.setPreferredSize(new java.awt.Dimension(80, 51));

        gplBut.setIcon(new javax.swing.ImageIcon(getClass().getResource("/com/dacopancm/dcmqueen/resources/gpl.png"))); // NOI18N

        helpBut.setIcon(new javax.swing.ImageIcon(getClass().getResource("/com/dacopancm/dcmqueen/resources/help.png"))); // NOI18N
        helpBut.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                helpButActionPerformed(evt);
            }
        });

        aboutBut.setIcon(new javax.swing.ImageIcon(getClass().getResource("/com/dacopancm/dcmqueen/resources/about.png"))); // NOI18N

        javax.swing.GroupLayout jPanel4Layout = new javax.swing.GroupLayout(jPanel4);
        jPanel4.setLayout(jPanel4Layout);
        jPanel4Layout.setHorizontalGroup(
            jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel4Layout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel4Layout.createSequentialGroup()
                        .addComponent(helpBut, javax.swing.GroupLayout.PREFERRED_SIZE, 42, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(aboutBut, javax.swing.GroupLayout.PREFERRED_SIZE, 42, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addComponent(gplBut, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 98, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap())
        );
        jPanel4Layout.setVerticalGroup(
            jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel4Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(gplBut)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(helpBut)
                    .addComponent(aboutBut))
                .addContainerGap())
        );

        javax.swing.GroupLayout jPanel7Layout = new javax.swing.GroupLayout(jPanel7);
        jPanel7.setLayout(jPanel7Layout);
        jPanel7Layout.setHorizontalGroup(
            jPanel7Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel7Layout.createSequentialGroup()
                .addGap(0, 0, Short.MAX_VALUE)
                .addComponent(jPanel4, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
        );
        jPanel7Layout.setVerticalGroup(
            jPanel7Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel7Layout.createSequentialGroup()
                .addComponent(jPanel4, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 0, Short.MAX_VALUE))
        );

        javax.swing.GroupLayout switchWrapperLayout = new javax.swing.GroupLayout(switchWrapper);
        switchWrapper.setLayout(switchWrapperLayout);
        switchWrapperLayout.setHorizontalGroup(
            switchWrapperLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(switchWrapperLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(switchWrapperLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(switchWrapperLayout.createSequentialGroup()
                        .addComponent(reloadBut)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(pausebutton)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(snapBut)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 88, Short.MAX_VALUE)
                        .addComponent(jPanel7, javax.swing.GroupLayout.PREFERRED_SIZE, 120, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(switchWrapperLayout.createSequentialGroup()
                        .addGroup(switchWrapperLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(velocityControl, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel1))
                        .addGap(57, 57, 57)
                        .addComponent(gauguesWrap1, javax.swing.GroupLayout.DEFAULT_SIZE, 252, Short.MAX_VALUE)))
                .addContainerGap())
        );
        switchWrapperLayout.setVerticalGroup(
            switchWrapperLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(switchWrapperLayout.createSequentialGroup()
                .addGroup(switchWrapperLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(switchWrapperLayout.createSequentialGroup()
                        .addGap(34, 34, 34)
                        .addGroup(switchWrapperLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(pausebutton)
                            .addComponent(reloadBut)
                            .addComponent(snapBut)))
                    .addComponent(jPanel7, javax.swing.GroupLayout.PREFERRED_SIZE, 114, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGroup(switchWrapperLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(switchWrapperLayout.createSequentialGroup()
                        .addGap(101, 101, 101)
                        .addComponent(jLabel1)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(velocityControl, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addContainerGap(196, Short.MAX_VALUE))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, switchWrapperLayout.createSequentialGroup()
                        .addGap(36, 36, 36)
                        .addComponent(gauguesWrap1, javax.swing.GroupLayout.DEFAULT_SIZE, 302, Short.MAX_VALUE)
                        .addContainerGap())))
        );

        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(switchWrapper, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jPanel5, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel2Layout.createSequentialGroup()
                        .addGap(0, 106, Short.MAX_VALUE)
                        .addComponent(jPanel6, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap())
        );
        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jPanel5, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(jPanel6, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(switchWrapper, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );

        jSplitPane1.setRightComponent(jPanel2);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jSplitPane1)
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jSplitPane1)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void helpButActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_helpButActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_helpButActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(MainView.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                MainView mv = new MainView();
                mv.setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton aboutBut;
    private javax.swing.JLayeredPane chessBoardWrapper;
    private javax.swing.JPanel gauge1Wrap;
    private javax.swing.JPanel gauge2Wrap;
    private javax.swing.JPanel gauguesWrap1;
    private javax.swing.JButton gplBut;
    private javax.swing.JButton helpBut;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JPanel jPanel4;
    private javax.swing.JPanel jPanel5;
    private javax.swing.JPanel jPanel6;
    private javax.swing.JPanel jPanel7;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JSplitPane jSplitPane1;
    private javax.swing.JTextArea noticex;
    private javax.swing.JToggleButton pausebutton;
    private javax.swing.JPanel queenWraper;
    private javax.swing.JButton reloadBut;
    private javax.swing.JButton snapBut;
    private javax.swing.JPanel switchWrapper;
    private javax.swing.JSlider velocityControl;
    // End of variables declaration//GEN-END:variables

    // <editor-fold defaultstate="collapsed" desc="init Configurations">
    /**
     * init All with default configs
     */
    private void initConfigs() {
        reloadChessboard();
        Border d = javax.swing.BorderFactory.createTitledBorder("");
        // chessBoardWrapper.setBorder(d);
        queenWraper.setBorder(d);

        loadQueens(true);

        iPause = new javax.swing.ImageIcon(getClass().getResource("/com/dacopancm/dcmqueen/resources/pause.png"));
        iPlay = new javax.swing.ImageIcon(getClass().getResource("/com/dacopancm/dcmqueen/resources/play.png"));

        initGaugues();
        //init threads
        algR = new AlgRunnable();
        alg = new Thread(algR);

        this.switchMode = new SteelCheckBox();
        //this.switchMode=new JButton(" xxx");
        switchMode.setPreferredSize(new Dimension(120, 30));
        switchMode.setBounds(25, 320, 120, 30);
        switchMode.setSelectedColor(eu.hansolo.tools.ColorDef.RED);
        switchMode.setColored(true);
        switchMode.setRised(true);
        switchMode.setText("Modo Juego");
        //switchMode.setSize(120, 300);*/

        switchWrapper.add(switchMode);
        userQueen = new ArrayList();
    }

    /**
     * init chessboard with default configs
     */
    private void reloadChessboard() {
        chessBoard = new ChessBoard();
        chessBoardWrapper.removeAll();
        chessBoardWrapper.setPreferredSize(new Dimension(560, 540));
        chessBoard.setBounds(30, 30, 560, 540);
        chessBoardWrapper.add(chessBoard);

    }

    /**
     * load the 8 queens before Chessboard
     *
     * @param ix
     */
    private void loadQueens(boolean enDrag) {
        System.out.println("Load queens: " + this.appMode);
        queenWraper.removeAll();
        // userQueen = new ArrayList();
        queens = new Queen[8];

        if (queens[0] != null) {
            for (int i = 0; i < 8; i++) {
                queens[i].removeMouseMotionListener(this);
                queens[i].removeMouseListener(this);
            }

        }
        final int SPACE = 20;
        Border d = javax.swing.BorderFactory.createTitledBorder("");
        for (int i = 0; i < 8; i++) {
            queens[i] = new Queen(QUEEN_SIZE - 20);
            queens[i].setBounds(QUEEN_SIZE * i + SPACE * 1, 30, QUEEN_SIZE, QUEEN_SIZE);
            queens[i].setBorder(d);
            queenWraper.add(queens[i]);
        }

        if (enDrag) {
            for (int i = 0; i < (this.appMode == AppMode.GAME ? 8 : 1); i++) {
                queenWraper.remove(queens[i]);
                //queenWraper.remove(queens[0]);
                Rectangle gb = queens[i].getBounds();
                gb.y = 100;
                gb.x += 20;
                queens[i].setBounds(gb);
                chessBoardWrapper.add(queens[i]);
                chessBoardWrapper.moveToFront(queens[i]);
                if (queens[i] != null && queens[i].isDraggable()) {
                    queens[i].addMouseMotionListener(this);
                    queens[i].addMouseListener(this);

                    noticex.setText("DCM Queen.");
                }
                //queenWraper.repaint();
            }
            showNotify("Mueva a la reina a la posicion deseada, para comenzar");
        }
        queenWraper.repaint();

    }
    // </editor-fold>
    // <editor-fold defaultstate="collapsed" desc="init ActionListeners and gauge">
    /**
     * inicializa los action listeners de todos los componentes q lo requieran
     */
    private void initActionListeners() {

        pausebutton.addActionListener(new java.awt.event.ActionListener() {

            @Override
            public void actionPerformed(ActionEvent e) {
                System.out.println("pause invoke");
                if (pause) {
                    pausebutton.setIcon(iPause);
                    pausebutton.setToolTipText("Pause");
                    gauge.setValueAnimated(velocityControl.getValue());
                    showNotify("DCM Queen", "Reanudando Animaci√≥n");
                } else {
                    pausebutton.setIcon(iPlay);
                    pausebutton.setToolTipText("Play");
                    gauge.setValueAnimated(0);
                    showNotify("DCM Queen", "Pausando Animaci√≥n");
                }
                pause = !pause;
            }
        });

        reloadBut.addActionListener(new java.awt.event.ActionListener() {

            @Override
            public void actionPerformed(ActionEvent e) {
                new Thread(new Runnable() {

                    @Override
                    public void run() {
                        System.out.println("reload invoke");
                        VELOCITY_ALG = 0;
                        toggleProgres(true);
                        if (pause) {
                            pausebutton.doClick();
                        }
                        enableDisableTools(false);
                        if (alg.isAlive()) {
                            pause = false;
                            algR.rebornThread();
                            algR.killThread();
                        }
                        try {

                            alg.join();
                            System.out.println("alg after join");
                            toggleProgres(false);
                            reloadChessboard();
                            System.out.println("before load queens reloadBut");
                            loadQueens(true);
                            pause = false;

                            initGaugues();
                            //enableDisableTools(true);

                            switchMode.setSelected(AppMode.GAME == appMode);
                            if (appMode == AppMode.GAME) {
                                enableDisableTools(false);
                                reloadBut.setEnabled(true);
                                snapBut.setEnabled(true);
                                VELOCITY_ALG = 0;

                                pause = false;
                            }
                            chessBoardWrapper.invalidate();
                            chessBoardWrapper.repaint();
                            userQueen = new ArrayList();

                        } catch (InterruptedException ex) {
                            System.out.println("Error: " + ex.getMessage());
                        }
                        switchWrapper.repaint();
                    }

                }).start();
            }
        });

        switchMode.addActionListener(new java.awt.event.ActionListener() {
            @Override
            public void actionPerformed(ActionEvent actionEvent) {

                final AbstractButton abstractButton = (AbstractButton) actionEvent.getSource();
                new Thread(new Runnable() {

                    @Override
                    public void run() {
                        boolean selected = abstractButton.getModel().isSelected();
                        enableDisableTools(true);

                        if (selected) {

                            appMode = AppMode.GAME;
                            reloadBut.doClick();

                            try {
                                Thread.sleep(300);
                            } catch (InterruptedException ex) {
                                Logger.getLogger(MainView.class.getName()).log(Level.SEVERE, null, ex);
                            }
                            appMode = AppMode.GAME;

                            showNotify("Modo Juego activado");
                        } else {
                            appMode = AppMode.ANIMATION;
                            reloadBut.doClick();
                            showNotify("Modo Animaci√≥n activado");
                        }

                    }
                }).start();
            }
        });

        velocityControl.addChangeListener(new javax.swing.event.ChangeListener() {
            @Override
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                gauge.setValueAnimated(velocityControl.getValue());
                VELOCITY_ALG = 80 - velocityControl.getValue();
            }
        });

        gplBut.addActionListener(new ActionListener() {

            @Override
            public void actionPerformed(ActionEvent e) {
                URL url;
                try {
                    url = new URL("http://www.gnu.org/licenses/gpl-3.0-standalone.html");
                    try {
                        DesktopApi.browse(url.toURI());
                    } catch (URISyntaxException ex) {
                        System.out.println(ex.getMessage());
                    }
                } catch (MalformedURLException e1) {
                    System.out.println(e1.getMessage());
                }
            }
        });

        aboutBut.addActionListener(new ActionListener() {

            @Override
            public void actionPerformed(ActionEvent e) {
                URL url;
                try {
                    url = new URL("http://dacopancm.hol.es/blog/about");
                    try {
                        DesktopApi.browse(url.toURI());
                    } catch (URISyntaxException ex) {
                        System.out.println(ex.getMessage());
                    }
                } catch (MalformedURLException e1) {
                    System.out.println(e1.getMessage());
                }
            }
        });
        helpBut.addActionListener(new ActionListener() {

            @Override
            public void actionPerformed(ActionEvent e) {
                callHelp();

            }
        });
        
         snapBut.addActionListener(new ActionListener() {

            @Override
            public void actionPerformed(ActionEvent e) {
                //chessBoard.getImg(System.getProperty("user.dir") + System.getProperty("file.separator") + "x.jpg");
                //System.out.println(System.getProperty("user.dir") + System.getProperty("file.separator") + "x.jpg");

                try {
                    saveDCM.setSelectedFile(new File("DCMQueen_Snapshot.jpg"));
                    if (saveDCM.showSaveDialog(getRootPane()) == JFileChooser.APPROVE_OPTION) {
                        File f = saveDCM.getSelectedFile();

                        String path = (f.getCanonicalPath() + (f.getCanonicalPath().endsWith(".jpg") ? "" : ".jpg")).replace("\\", "/");
                        System.out.println(path);
                        boolean _r = chessBoard.getImg(path);
                        if (_r) {
                            showNotify("DCM Queen", "Reinas hiperactivas guardadas con √©xito");
                        } else {
                            showNotify("DCM Queen Error", "Lamentamos, hemos teneido inconvenientes generando la captura");
                        }
                    }
                } catch (HeadlessException | IOException ex) {
                    showNotify("DCM Queen Error", "Lamentamos, hemos teneido inconvenientes generando la captura: " + ex.getMessage());
                }

            }
        });
         
        jSplitPane1.registerKeyboardAction(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                callHelp();
            }
        }, KeyStroke.getKeyStroke("F1"), JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);

        jSplitPane1.registerKeyboardAction(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {                
                Egg.main(null);
            }
        }, KeyStroke.getKeyStroke("control alt M"), JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);

       //reload short cut
        jSplitPane1.registerKeyboardAction(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                reloadBut.doClick();
            }
        }, KeyStroke.getKeyStroke("control R"), JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);

        //snap short cut
        jSplitPane1.registerKeyboardAction(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                snapBut.doClick();
            }
        }, KeyStroke.getKeyStroke("control S"), JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);

        //play/pause short cut
        jSplitPane1.registerKeyboardAction(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                pausebutton.doClick();
            }
        }, KeyStroke.getKeyStroke("control P"), JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);

    }

    /**
     * inicializa y configura el gauge de velocidad y el slider
     */
    private void initGaugues() {
        gauguesWrap1.removeAll();
        gauge1Wrap.removeAll();
        gauge2Wrap.removeAll();

        gauge = new eu.hansolo.steelseries.gauges.Radial();
        gauge.setBounds(0, 0, 200, 200);
        gauge.setPreferredSize(new Dimension(200, 200));
        gauge.setUnitString("ejecuci√≥n");
        gauge.setPointerType(PointerType.TYPE1);
        gauge.setTitle("Velocidad");

        gauge.setPointerColor(ColorDef.ORANGE);
        //r.setBackgroundColor(BackgroundColor.NOISY_PLASTIC);
        gauge.setBackgroundColor(BackgroundColor.PUNCHED_SHEET);

        gauge.setMaxValue(80);
        gauge.setMinValue(0);
        gauge.setValue(6.8);
        //LCD
        gauge.setLcdColor(LcdColor.GREEN_LCD);
        gauge.setLcdDecimals(2);
        gauge.setDigitalFont(true);
        //track        
        gauge.setTrackStart(60);
        gauge.setTrackStartColor(Color.GREEN);
        gauge.setTrackSection(70);
        gauge.setTrackSectionColor(Color.YELLOW);
        gauge.setTrackStop(80);
        gauge.setTrackStopColor(Color.RED);
        gauge.setHighlightSection(false);
        gauge.setTrackVisible(true);

        DesignModel night = new DesignModel.Builder().frameDesign(FrameDesign.BLACK_METAL)
                .backgroundColor(BackgroundColor.BLACK).lcdColor(LcdColor.GREEN_LCD)
                .color(ColorDef.RED)
                .build();

        gauguesWrap1.add(gauge);

        //SLIDER
        velocityControl.setMinimum(1);
        velocityControl.setMaximum(80);
        velocityControl.setValue(15);

        //solutions gaugues
        gaugeSol1 = new eu.hansolo.steelseries.gauges.DisplaySingle();
        gaugeSol1.setBounds(10, 10, 80, 50);
        gaugeSol1.setDigitalFont(true);
        gaugeSol1.setLcdColor(LcdColor.DARKBLUE_LCD);
        gaugeSol1.setLcdDecimals(0);
        gaugeSol1.setLcdUnitString("Sol.");
        gaugeSol1.setLcdValueAnimated(0);

        gauge1Wrap.add(gaugeSol1);

        gaugeSol2 = new eu.hansolo.steelseries.gauges.DisplaySingle();
        gaugeSol2.setBounds(10, 70, 80, 50);
        gaugeSol2.setDigitalFont(true);
        gaugeSol2.setLcdColor(LcdColor.REDDARKRED_LCD);
        gaugeSol2.setLcdDecimals(0);
        gaugeSol2.setLcdUnitString("Sol.");
        gaugeSol2.setLcdValueAnimated(0);

        gauge1Wrap.add(gaugeSol2);
        gauge1Wrap.setPreferredSize(new Dimension(100, 120));

        //counter gauges
        gaugeSol3 = new eu.hansolo.steelseries.gauges.DisplaySingle();
        gaugeSol3.setBounds(10, 10, 180, 50);
        gaugeSol3.setDigitalFont(true);
        gaugeSol3.setLcdColor(LcdColor.GRAY_LCD);
        gaugeSol3.setLcdDecimals(0);
        gaugeSol3.setLcdUnitString("Backtraking");
        gaugeSol3.setLcdValueAnimated(0);

        gauge2Wrap.add(gaugeSol3);

        gaugeSol4 = new eu.hansolo.steelseries.gauges.DisplaySingle();
        gaugeSol4.setBounds(200, 10, 170, 50);
        gaugeSol4.setDigitalFont(true);
        gaugeSol4.setLcdColor(LcdColor.DARKBLUE_LCD);
        gaugeSol4.setLcdDecimals(0);
        gaugeSol4.setLcdUnitString("recursive");
        gaugeSol4.setLcdValueAnimated(0);

        gauge2Wrap.add(gaugeSol4);

        gaugeSol5 = new eu.hansolo.steelseries.gauges.SparkLine();
        gaugeSol5.setBounds(10, 70, 360, 70);
        gaugeSol5.setBackgroundVisible(true);
        gaugeSol5.setHiLoIndicatorVisible(true);
        gaugeSol5.setStartStopIndicatorVisible(true);
        gaugeSol5.setInfoLabelsVisible(true);
        gaugeSol5.setFilled(true);

        gaugeSol5.setSparkLineColor(LcdColor.REDDARKRED_LCD);
        //gaugeSol5.addDataPoint(0);
        gaugeSol5.setSmoothFunction(SmoothingFunction.HERMITE);
        gaugeSol5.setSmoothing(false);

        gaugeSol5.setTimeFrame(100);
//        gaugeSol5.addDataPoint(1,20);
//        gaugeSol5.setTimeFrame(20);
//        gaugeSol5.addDataPoint(2,40);
//        gaugeSol5.setTimeFrame(40);
//        gaugeSol5.addDataPoint(3,60);
//        gaugeSol5.setTimeFrame(60);
//        gaugeSol5.addDataPoint(4,80);
//        gaugeSol5.addDataPoint(1,90);
//        //gaugeSol5.setTimeFrame(90);
        gauge2Wrap.add(gaugeSol5);

    }

    // </editor-fold>
    // <editor-fold defaultstate="collapsed" desc="Helpers, notifys, etc">
    public void showNotify(String text) {
        showNotify("DCM Queen", text);
    }

    /**
     * Muestra notificacion Toast
     *
     * @param title
     * @param text
     */
    public void showNotify(String title, String text) {
        try {
            AchievementConfig config = new AchievementConfig();

            config.setBackgroundColor(new java.awt.Color(13, 142, 161));
            config.setTitleColor(Color.WHITE);
            config.setDescriptionColor(Color.WHITE);
            config.setBorderColor(new java.awt.Color(58, 161, 192));
            config.setAchievementPosition(AchievementPosition.TOP_RIGHT);
            config.setDuration(2500);
            //config.setIcon(new javax.swing.ImageIcon(getClass().getResource("/com/dacopancm/dcmqueen/resources/queen2.png")));
            config.setIcon(Queen.icon);
            //config.setAudioInputStream(null);

            Achievement achievement = new Achievement(title, text, config);
            AchievementQueue queue = new AchievementQueue();
            queue.add(achievement);
        } catch (Exception ex) {
//            Log.e("Error", "su OS no soporta notificaciones", ex);
        }
    }

    /**
     * enable/disable pause and refresh buttons
     *
     * @param act enable/disable
     */
    private void enableDisableTools(boolean act) {

        try {
            pausebutton.setEnabled(act);
            reloadBut.setEnabled(act);
            snapBut.setEnabled(act);
            velocityControl.setEnabled(act);
            gauge.setEnabled(act);
            if (act) {
                velocityControl.setValue(35);
                gauge.setValue(35);
            }
        } catch (Exception ex) {
            System.out.println("(e)enableDisableTools: " + ex.getMessage());
        }
    }

    /**
     * muestra la ayuda en formato HTML5 en el navegador web predeterminado en
     * el Sistema operativo. Solo Windows
     */
    private void callHelp() {
        URL url;
        try {

            String userDir = System.getProperty("user.dir");
            String spliter = System.getProperty("file.separator");
            // String filePath = userDir + spliter + "resources" + spliter + "help" + spliter + "index.html";
            String filePath = "resources" + spliter + "help" + spliter + "index.html";
            File fileHelp = new File(filePath);
            if (fileHelp.exists()) {
                //fileHelp.delete();
                System.out.println("help exist");

            }
            url = fileHelp.toURI().toURL();
            //InputStream streamIn = getClass().getResourceAsStream("/com/dacopancm/ordenamientos/resources/help.html");
            //Files.copy(streamIn, fileHelp.toPath());
            try {
                DesktopApi.browse(url.toURI());
            } catch (URISyntaxException ex) {
                System.out.println("error: " + ex.getMessage());
            }
        } catch (MalformedURLException e1) {
            System.out.println("error: " + e1.getMessage());
        }
    }

    /**
     * show/ocult progressring en lugar de chessBoard
     *
     * @param b true show progress
     */
    private void toggleProgres(boolean b) {
        chessBoard.toggleProgres(b, (this.appMode == AppMode.ANIMATION ? "Killing Queens, Wait" : "Intercambiando Modo"));
    }

    private void toggleProgres(boolean b, String text) {
        chessBoard.toggleProgres(b, text);
    }

    /**
     * clase para filtar extensiones JFileChooser
     */
    class DCMFIlter extends javax.swing.filechooser.FileFilter {

        @Override
        public boolean accept(File f) {
            return f.isDirectory() || f.getName().toLowerCase().endsWith(".jpg");
        }

        @Override
        public String getDescription() {
            return "Imagenes (.jpg)";
        }
    }

    // </editor-fold>
    // <editor-fold defaultstate="collapsed" desc="Mouse Listener">
    //todos estos metodos son para controlae el drag & drog de la primera reina
    @Override
    public void mouseClicked(MouseEvent e) {
        if (this.appMode == AppMode.GAME) {
            Queen qq = (Queen) e.getSource();
            if (!qq.isDraggable()) {
                Container parent = qq.getParent();
                Rectangle rc = parent.getBounds();
                Rectangle rc2 = qq.getBounds();
                rc2.x = rc.x;
                rc2.y = rc.y;
                chessBoard.cleenCell(parent);
                parent.repaint();

                qq.setBounds(rc2);
                chessBoardWrapper.add(qq);
                chessBoardWrapper.moveToFront(qq);
                chessBoard.repaint();
                qq.setDraggable(true);
            }
        }
    }

    @Override
    public void mousePressed(MouseEvent e) {
        //showNotify(null);
        System.out.println("drag start");
    }

    @Override
    public void mouseReleased(MouseEvent e) {
        Queen qq = (Queen) e.getSource();
        System.out.println("Fin draged");
        int x = qq.getX() - 30;
        int y = qq.getY() - 30;
        boolean isLastQueen = true;
        if (qq.isDraggable()) {
            qq.setDraggable(false);
            int _r = 0;
            if (appMode == AppMode.GAME) {
                for (Queen qqc : queens) {
                    if (qqc.isDraggable()) {
                        isLastQueen = false;
                        break;
                    }
                }
            }
            if (isLastQueen) {
                _r = JOptionPane.showConfirmDialog(this, "Colocar reina y comenzar ?", "DCM Queen ", JOptionPane.YES_NO_OPTION);
            }

            if (_r == 0) {
                boolean _r2 = chessBoard.addAtCell(new Point(x, y), qq);
                if (qq.getPoint() != null) {
                    userQueen.remove(qq.getPoint());
                }
                userQueen.add(chessBoard.getUserSelectPoint());
                qq.setPoint(chessBoard.getUserSelectPoint());
                if (_r2) {

                    qq.setDraggable(false);
                    qq.setBounds(0, 0, qq.getWidth(), qq.getHeight());
                    chessBoardWrapper.remove(qq);
                    chessBoard.repaint();

                    if (this.appMode == AppMode.ANIMATION || isLastQueen) {
                        showNotify("Iniciando animacion");
                        executeAlg();
                    }

                } else {
                }
            } else {
                qq.setDraggable(true);
            }
        }
    }

    @Override
    public void mouseEntered(MouseEvent e) {
        //   System.out.println("XX");
    }

    @Override
    public void mouseExited(MouseEvent e) {
        // System.out.println("XX");
    }
//drag

    @Override
    public void mouseDragged(MouseEvent E) {
        Queen qq = (Queen) E.getSource();
        if (qq.isDraggable()) {
            int X = E.getX() + qq.getX();
            int Y = E.getY() + qq.getY();
            int chessX = chessBoard.getBounds().x;
            int chessY = chessBoard.getBounds().y;

            int maxX = chessX + chessBoard.getBounds().width;
            int maxY = chessY + chessBoard.getBounds().height;
            if ((X + QUEEN_SIZE) > maxX) {
                X = maxX - QUEEN_SIZE;
            } else if ((X) < chessX) {
                X = chessX;
            }
            if ((Y + QUEEN_SIZE) > maxY) {
                Y = maxY - QUEEN_SIZE;
            } else if ((Y) < chessY) {
                Y = chessY;
            }
            qq.setBounds(X, Y, QUEEN_SIZE, QUEEN_SIZE);
        }
    }

    @Override
    public void mouseMoved(MouseEvent e) {

    }
// </editor-fold>

    // <editor-fold defaultstate="collapsed" desc="Therads">
    private void executeAlg() {
        enableDisableTools(true);
        if (appMode == AppMode.GAME) {
            enableDisableTools(false);
            reloadBut.setEnabled(true);
            snapBut.setEnabled(true);
            VELOCITY_ALG = 0;
            pause = false;
        }
        alg = new Thread(algR);
        algR.rebornThread();
        alg.start();
    }

    /**
     * el Runnable encargado de la MAGIA
     */
    private class AlgRunnable implements Runnable {

        private boolean killed;
        private List<Integer> Solution;
        private List<Integer> ans;
        int VELOCITY_ALG2 = 100;
        private int solu1 = 0;
        private int solu2 = 0;
        private int calls = 0;
        private int backtraking = 0;
        private int backtraking2 = 0;
        private int time = 0;
        private boolean isGameOver;

        /**
         * asesina al Thread
         */
        public void killThread() {
            this.killed = true;
        }

        /**
         * revive al Thread
         */
        public void rebornThread() {
            this.killed = false;
        }

        /**
         * inicia la magia
         */
        @Override
        public void run() {
            BitSet RowsToBeFilled = new BitSet(9);
            BitSet ColsToBeFilled = new BitSet(9);
            BitSet LeftDiag = new BitSet(16);
            BitSet RightDiag = new BitSet(16);
            for (int i = 1; i < 9; i++) {
                RowsToBeFilled.set(i);
                ColsToBeFilled.set(i);
            }
            for (int j = 1; j < 16; j++) {
                LeftDiag.set(j);
                RightDiag.set(j);
            }
            this.Solution = new ArrayList();
            backtraking = 0;
            backtraking2 = 0;
            if (appMode == AppMode.GAME) {
                toggleProgres(true, "Verificando soluci√≥n");
                VELOCITY_ALG = 0;
                gauge.setValue(80);
                VELOCITY_ALG = 0;
                isGameOver = true;

            }

            backtraking(RowsToBeFilled, ColsToBeFilled, LeftDiag, RightDiag);
            //call algoritm
            if (appMode == AppMode.GAME) {
                String content;
                if (isGameOver) {
                    content = "Game Over";
                } else {
                    content = "Enhorabuena, ganaste";
                }
                toggleProgres(true);

                showNotify(content);
                //chessBoard.repaint();
                chessBoard.gameEnd(content);
            }

            switchWrapper.repaint();
            /*
             try {
             Thread.sleep(1000000000);
             } catch (InterruptedException ex) {
             Logger.getLogger(MainView.class.getName()).log(Level.SEVERE, null, ex);
             }//*/
        }

        /**
         * El MAGO, metodo backtraking recursivo que encuentra las soluciones
         *
         * @param RowsToBeFilled
         * @param ColsToBeFilled
         * @param LeftDiag
         * @param RightDiag
         */
        private void backtraking(BitSet RowsToBeFilled, BitSet ColsToBeFilled, BitSet LeftDiag, BitSet RightDiag) {
            pauseAlg();//CHECK PAUSE
            if (killed) {
                System.out.println("KILLED");
                return;
            }
            if (setSelected(0)) {
                return;
            }
            try {
                Thread.sleep(VELOCITY_ALG * 80 + 10);
                // Thread.yield();
            } catch (InterruptedException le) {
            }
            fireCallEvent();
            if (setSelected(3)) {
                return;
            }
            if (setSelected(3, "Declarar variables locales para la llamada de este metodo")) {
                return;
            }

            if (setSelected(4, "Hacer una copia de los BitSet para que los cambios puedan ser echos al BitSet localmente sin cambiar al BitSet pasado en la la llamada al m√©todo")) {
                return;
            }

            BitSet localBitSet1 = (BitSet) ColsToBeFilled.clone();

            BitSet localBitSet2 = (BitSet) RowsToBeFilled.clone();
            if (setSelected(6, "El primer paso en cualquier soluci√≥n recursiva es comprobar si el problema encaja en la categor√≠a de caso base. En este caso, comprobamos para ver si ocho reina han sido retardada en el tablero de ajedrez? - El caso base para el Eight Queens problema.")) {
                return;
            }
            if (empty(RowsToBeFilled)) {
                if (setSelected(7, "Se ha llegado al caso base se ha encontrado una soluci√≥n. Observe que el sparkline est√° mostrando 9 llamadas recursivas abierto. Esto se debe a que no es hasta la novena llamada que el caso base est√° satisfecho.")) {
                    return;
                }

                updateDisplay(this.Solution, true);
                //fireSolutionEvent();        
                //backtraking2 = 1;
                gaugeSol5.addDataPoint(0, ++time);
                gaugeSol1.setLcdValueAnimated(++solu1);
                chessBoard.repaint();

                if (checkSolution()) {
                    pausebutton.doClick();
                    showNotify("Soluci√≥n encontrada");
                    gaugeSol2.setLcdValueAnimated(++solu2);
                    // chessBoard.repaint();

                    if (appMode == AppMode.GAME) {
                        System.out.println("Modo juego solucion encontrada");
                        isGameOver = false;
                        pause = false;
                        killThread();
                        return;
                    }
                }
                try {
                    Thread.sleep(2000L);
                } catch (InterruptedException le) {
                    System.out.println("???");
                }

                if (setSelected(10, "Backtrack y tratar de encontrar otras soluciones")) {
                    //return;
                }
            } else {
                if (setSelected(11, "Como se puede ver en la animaci√≥n que todav√≠a no hemos llegado a la hip√≥tesis de base, ya que s√≥lo "
                        + count(RowsToBeFilled)
                        + " Queens se han colocado en el tablero.")) {
                    return;
                }

                if (setSelected(13, " Busca la siguiente fila donde se debe colocar una reina (i.e, Fila" + (count(RowsToBeFilled) + 1) + ")")) {
                    return;
                }
                int i = AnyFrom(localBitSet2);
                if (setSelected(14, " ajustar CopyOfRowsToBeFilled de manera que la fila " + (count(RowsToBeFilled) + 1)
                        + " ahora se marca como una reina colocada all√≠.")) {
                    return;
                }
                localBitSet2.clear(i);

                if (setSelected(15, " Ahora tenemos que decidir d√≥nde en la columna "
                        + count(localBitSet2)
                        + " podemos colocar una reina sin ser atacados "
                        + "por otra(s) reina(s)"
                        + "que ya est√°n en el tablero")) {
                    return;
                }
                while (!empty(localBitSet1)) {
                    if (killed) {
                        System.out.println("KILLED 2");
                        return;
                    }
                    pauseAlg();//CHECK PAUSE
                    if (setSelected(16)) {
                        return;
                    }
                    int j = AnyFrom(localBitSet1);
                    if (setSelected(17, " Pruebe a ver si es seguro para colocar una reina en posici√≥n " + j
                            + " de columna " + count(localBitSet2) + ".")) {
                        return;
                    }

                    try {
                        localBitSet1.clear(j);
                    } catch (Exception e) {
                        System.out.println("BITSET ERROR");
                    }

                    if ((LeftDiag.get(i + j - 1) & RightDiag.get(i - j + 8))) {
                        if (setSelected(20, "Posici√≥n " + j
                                + " de comlumna " + count(localBitSet2)
                                + " es una posici√≥n segura para una Reina.")) {
                            return;
                        }

                        try {
                            this.Solution.add(j);
                        } catch (Exception e) {
                            System.out.println("ERROR: " + e.getMessage());
                        }
                        updateDisplay(this.Solution);
                        // Thread.yield();
                        if (setSelected(22, " Por colocar una Reina en la posici√≥n " + j
                                + " de la columna " + count(localBitSet2)
                                + " cualquier posici√≥n a lo largo de las diagonales de esta posici√≥n se convierten en "
                                + " inseguro para otra reina. Registramos las diagonales"
                                + " efectuado aqu√≠.")) {
                            return;
                        }
                        ColsToBeFilled.clear(j);

                        LeftDiag.clear(i + j - 1);

                        RightDiag.clear(i - j + 8);
                        if (setSelected(25,
                                "Ahora hacemos una llamada recursiva para tratar de encontrar la siguiente ubicaci√≥n para una reina. Como acabamos elaborado un lugar seguro en esta fila se pidi√≥ la llamada recursiva para resolver una versi√≥n simplificada del mismo problema. Observe que el sparkline aumento.")) {
                            return;
                        }

                        backtraking(localBitSet2, ColsToBeFilled,
                                LeftDiag, RightDiag);
                        if (setSelected(27, " Este es el punto de retorno de una llamada recursiva, el sparkline se reduce en uno, La soluci√≥n que se ha sugerido se ha intentado, liberar la posici√≥n que hab√≠a colocado una reina para que yo pudiera sugerir otra soluci√≥n")) {
                            return;
                        }

                        fireBackTrackEvent();
                        ColsToBeFilled.set(j);

                        this.Solution.remove(this.Solution.size() - 1);

                        pauseAlg();//CHECK PAUSE
                        if (killed) {
                            System.out.println("KILLED3");
                            return;
                        }

                        updateDisplay(this.Solution);

                        LeftDiag.set(i + j - 1);

                        RightDiag.set(i - j + 8);
                    } else {
                        if (setSelected(15, "No es seguro para colocar una reina en la posici√≥n " + j
                                + " de la columna " + count(localBitSet2)
                                + "¬† Ser√≠a atacada a lo largo de una de sus diagonales.")) {
                            return;
                        }
                    }

                }
                if (setSelected(33, "No hay posiciones m√°s seguras para poner a prueba en la fila actual, el tiempo de hacer un backtrack!")) {

                }
            }

        }

        /**
         * la magia misma, actualiza el chessBoard
         *
         * @param paramVector solucion
         */
        public void updateDisplay(List<Integer> paramVector) {
            this.ans = paramVector;
            pushQueens();
        }

        /**
         * la magia misma, actualiza el chessBoard
         *
         * @param paramVector solucion
         */
        public void updateDisplay(List<Integer> paramVector, boolean paramBoolean) {
            this.ans = paramVector;
            pushQueens();
        }

        /**
         * coloca las reinas necesarias, en el chessboard
         */
        private void pushQueens() {
            chessBoard.removeAllQueens();
            if ((this.ans != null) && (!this.ans.isEmpty())) {
                int m;
                loadQueens(false);
                for (m = 0; m < this.ans.size(); m++) {
                    int x = m;
                    int y = 0;
                    try {
                        y = (this.ans.get(m) - 1);
                    } catch (Exception e) {
                    }
                    System.out.println("Push queens:(" + x + ", " + y + ")");

                    chessBoard.addCom(x, y, queens[m]);
                    queens[m].setBounds(0, 0, queens[0].getWidth(), queens[0].getHeight());
                    chessBoard.repaint();
                    queenWraper.remove(queens[m]);
                    queenWraper.repaint();
                }

            }/* else if ((this.ans != null) && (this.ans.isEmpty())) {
             //this.buff.setColor(Color.blue);
             }*/

        }

        /**
         * retorna un int Pos vacia del BitSet
         *
         * @param paramBitSet bitSet de donde obtener el nuemro
         * @return
         */
        private int AnyFrom(BitSet paramBitSet) {
            int i = 1;
            while (!paramBitSet.get(i)) {
                i++;
            }
            return i;
        }

        /**
         * comprueba si esta vacio el BitSet
         *
         * @param paramBitSet true si esta vacio el BitSet
         * @return
         */
        private boolean empty(BitSet paramBitSet) {
            for (int i = 1; i < 9; i++) {
                if (paramBitSet.get(i)) {
                    return false;
                }
            }
            return true;
        }

        /**
         * Cuenta en el BitSet
         *
         * @param paramBitSet el count del BitSet
         * @return
         */
        private int count(BitSet paramBitSet) {
            int i = 0;
            for (int j = 1; j < 9; j++) {
                if (!paramBitSet.get(j)) {
                    i++;
                }
            }
            return i;
        }

        /**
         * Checa y comprueba si se pausa el algoritmo
         */
        private void pauseAlg() {
            if (pause) {
                try {
                    Thread.sleep(500);
                } catch (InterruptedException ex) {
                }
                pauseAlg();
            }
        }

        /**
         * Muestra en el Noticex un status
         *
         * @param i linea
         * @return
         */
        private boolean setSelected(int i) {
            System.out.println(i);
            return false;
        }

        /**
         * Muestra en el Noticex un status
         *
         * @param i
         * @param s status a mostrar
         * @return si se mato al hilo
         */
        private boolean setSelected(int i, String s) {
            System.out.println(i + ": " + s);
            noticex.setText(s);
            try {
                //  Thread.currentThread();
                Thread.sleep(VELOCITY_ALG * 80 + 1);
            } catch (InterruptedException lie) {
                System.out.println("Wake up and do some thing");
            }
            return killed;
        }

        /**
         * comprueba si la solucion encontrada contiene, a la reina ubicada en
         * la posicion seleccionada por el usuario
         *
         * @param ans solucion encontrada
         * @return true si es la solucion buscada
         */
        private boolean checkSolution() {
            List<Point> solPoints = new ArrayList();
            for (int m = 0; m < this.ans.size(); m++) {
                // chessBoard.addCom(m, m, this);
                int x = m;
                int y = ((this.ans.get(m)) - 1);
                solPoints.add(new Point(x, y));
            }

            return solPoints.containsAll(userQueen);
        }

        /**
         * evento cuando se llama el metodo, aumenta/disminuye los counter
         * necesarios
         */
        private void fireCallEvent() {
            gaugeSol3.setLcdValueAnimated(++calls);
            //time+=20;
            //gaugeSol5.setTimeFrame(time += 20);
            //gaugeSol5.setTimeFrame(time = 200);
            gaugeSol5.addDataPoint(++backtraking2, ++time);
            System.out.printf("dataPoint %d,%d\n\n", backtraking2, time);
        }

        /**
         * evento cuando se hace BackTrack, aumenta/disminuye los counter
         * necesarios
         */
        private void fireBackTrackEvent() {
            gaugeSol4.setLcdValueAnimated(++backtraking);

            //gaugeSol5.setTimeFrame(time += 20);
            gaugeSol5.addDataPoint(--backtraking2, ++time);
            System.out.printf("dataPoint %d,%d\n\n", backtraking2, time);
        }
    }
        // </editor-fold>

    // <editor-fold defaultstate="collapsed" desc="Variable declaration">
    private ChessBoard chessBoard;
    private boolean pause = false;
    private int VELOCITY_ALG;
    private ImageIcon iPause;
    private ImageIcon iPlay;
    private eu.hansolo.steelseries.gauges.Radial gauge;
    private Queen[] queens;
    private Thread alg;
    private AlgRunnable algR;
    final int QUEEN_SIZE = 70;
    private final JFileChooser saveDCM;
    private List<Point> userQueen;

    private eu.hansolo.steelseries.gauges.DisplaySingle gaugeSol1;
    private eu.hansolo.steelseries.gauges.DisplaySingle gaugeSol2;
    private eu.hansolo.steelseries.gauges.DisplaySingle gaugeSol3;
    private eu.hansolo.steelseries.gauges.DisplaySingle gaugeSol4;
    private eu.hansolo.steelseries.gauges.SparkLine gaugeSol5;

    eu.hansolo.custom.SteelCheckBox switchMode;
//    JButton switchMode;
    AppMode appMode;

    public enum AppMode {

        GAME, ANIMATION
    }
    // </editor-fold>
}
